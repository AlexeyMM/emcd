// Code generated by mockery v2.43.2. DO NOT EDIT.

package service

import (
	context "context"

	decimal "github.com/shopspring/decimal"
	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/service/accounting/model"

	time "time"
)

// MockPayouts is an autogenerated mock type for the Payouts type
type MockPayouts struct {
	mock.Mock
}

type MockPayouts_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPayouts) EXPECT() *MockPayouts_Expecter {
	return &MockPayouts_Expecter{mock: &_m.Mock}
}

// CheckFreePayoutTransaction provides a mock function with given fields: ctx, accountId, transactionId
func (_m *MockPayouts) CheckFreePayoutTransaction(ctx context.Context, accountId int64, transactionId int64) (decimal.Decimal, error) {
	ret := _m.Called(ctx, accountId, transactionId)

	if len(ret) == 0 {
		panic("no return value specified for CheckFreePayoutTransaction")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) (decimal.Decimal, error)); ok {
		return rf(ctx, accountId, transactionId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) decimal.Decimal); ok {
		r0 = rf(ctx, accountId, transactionId)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, accountId, transactionId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_CheckFreePayoutTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckFreePayoutTransaction'
type MockPayouts_CheckFreePayoutTransaction_Call struct {
	*mock.Call
}

// CheckFreePayoutTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId int64
//   - transactionId int64
func (_e *MockPayouts_Expecter) CheckFreePayoutTransaction(ctx interface{}, accountId interface{}, transactionId interface{}) *MockPayouts_CheckFreePayoutTransaction_Call {
	return &MockPayouts_CheckFreePayoutTransaction_Call{Call: _e.mock.On("CheckFreePayoutTransaction", ctx, accountId, transactionId)}
}

func (_c *MockPayouts_CheckFreePayoutTransaction_Call) Run(run func(ctx context.Context, accountId int64, transactionId int64)) *MockPayouts_CheckFreePayoutTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockPayouts_CheckFreePayoutTransaction_Call) Return(_a0 decimal.Decimal, _a1 error) *MockPayouts_CheckFreePayoutTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_CheckFreePayoutTransaction_Call) RunAndReturn(run func(context.Context, int64, int64) (decimal.Decimal, error)) *MockPayouts_CheckFreePayoutTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIncomeOperations provides a mock function with given fields: ctx, query
func (_m *MockPayouts) CheckIncomeOperations(ctx context.Context, query model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error) {
	ret := _m.Called(ctx, query)

	if len(ret) == 0 {
		panic("no return value specified for CheckIncomeOperations")
	}

	var r0 []*model.IncomeWithFee
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error)); ok {
		return rf(ctx, query)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckIncomeOperationsQuery) []*model.IncomeWithFee); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.IncomeWithFee)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.CheckIncomeOperationsQuery) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_CheckIncomeOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIncomeOperations'
type MockPayouts_CheckIncomeOperations_Call struct {
	*mock.Call
}

// CheckIncomeOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - query model.CheckIncomeOperationsQuery
func (_e *MockPayouts_Expecter) CheckIncomeOperations(ctx interface{}, query interface{}) *MockPayouts_CheckIncomeOperations_Call {
	return &MockPayouts_CheckIncomeOperations_Call{Call: _e.mock.On("CheckIncomeOperations", ctx, query)}
}

func (_c *MockPayouts_CheckIncomeOperations_Call) Run(run func(ctx context.Context, query model.CheckIncomeOperationsQuery)) *MockPayouts_CheckIncomeOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.CheckIncomeOperationsQuery))
	})
	return _c
}

func (_c *MockPayouts_CheckIncomeOperations_Call) Return(_a0 []*model.IncomeWithFee, _a1 error) *MockPayouts_CheckIncomeOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_CheckIncomeOperations_Call) RunAndReturn(run func(context.Context, model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error)) *MockPayouts_CheckIncomeOperations_Call {
	_c.Call.Return(run)
	return _c
}

// CheckOthers provides a mock function with given fields: ctx, queryParams
func (_m *MockPayouts) CheckOthers(ctx context.Context, queryParams model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for CheckOthers")
	}

	var r0 []*model.OtherOperationsWithTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckOtherQuery) []*model.OtherOperationsWithTransaction); ok {
		r0 = rf(ctx, queryParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OtherOperationsWithTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.CheckOtherQuery) error); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_CheckOthers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckOthers'
type MockPayouts_CheckOthers_Call struct {
	*mock.Call
}

// CheckOthers is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams model.CheckOtherQuery
func (_e *MockPayouts_Expecter) CheckOthers(ctx interface{}, queryParams interface{}) *MockPayouts_CheckOthers_Call {
	return &MockPayouts_CheckOthers_Call{Call: _e.mock.On("CheckOthers", ctx, queryParams)}
}

func (_c *MockPayouts_CheckOthers_Call) Run(run func(ctx context.Context, queryParams model.CheckOtherQuery)) *MockPayouts_CheckOthers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.CheckOtherQuery))
	})
	return _c
}

func (_c *MockPayouts_CheckOthers_Call) Return(_a0 []*model.OtherOperationsWithTransaction, _a1 error) *MockPayouts_CheckOthers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_CheckOthers_Call) RunAndReturn(run func(context.Context, model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error)) *MockPayouts_CheckOthers_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPayoutBlockStatus provides a mock function with given fields: ctx, transactionIds
func (_m *MockPayouts) CheckPayoutBlockStatus(ctx context.Context, transactionIds []int64) ([]*model.PayoutBlockStatus, error) {
	ret := _m.Called(ctx, transactionIds)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayoutBlockStatus")
	}

	var r0 []*model.PayoutBlockStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int64) ([]*model.PayoutBlockStatus, error)); ok {
		return rf(ctx, transactionIds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int64) []*model.PayoutBlockStatus); ok {
		r0 = rf(ctx, transactionIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutBlockStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int64) error); ok {
		r1 = rf(ctx, transactionIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_CheckPayoutBlockStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPayoutBlockStatus'
type MockPayouts_CheckPayoutBlockStatus_Call struct {
	*mock.Call
}

// CheckPayoutBlockStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionIds []int64
func (_e *MockPayouts_Expecter) CheckPayoutBlockStatus(ctx interface{}, transactionIds interface{}) *MockPayouts_CheckPayoutBlockStatus_Call {
	return &MockPayouts_CheckPayoutBlockStatus_Call{Call: _e.mock.On("CheckPayoutBlockStatus", ctx, transactionIds)}
}

func (_c *MockPayouts_CheckPayoutBlockStatus_Call) Run(run func(ctx context.Context, transactionIds []int64)) *MockPayouts_CheckPayoutBlockStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int64))
	})
	return _c
}

func (_c *MockPayouts_CheckPayoutBlockStatus_Call) Return(_a0 []*model.PayoutBlockStatus, _a1 error) *MockPayouts_CheckPayoutBlockStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_CheckPayoutBlockStatus_Call) RunAndReturn(run func(context.Context, []int64) ([]*model.PayoutBlockStatus, error)) *MockPayouts_CheckPayoutBlockStatus_Call {
	_c.Call.Return(run)
	return _c
}

// FindPayoutsForBlock provides a mock function with given fields: ctx, coinID, minPay, timestamp
func (_m *MockPayouts) FindPayoutsForBlock(ctx context.Context, coinID int64, minPay float32, timestamp time.Time) ([]*model.PayoutForBlock, error) {
	ret := _m.Called(ctx, coinID, minPay, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for FindPayoutsForBlock")
	}

	var r0 []*model.PayoutForBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, float32, time.Time) ([]*model.PayoutForBlock, error)); ok {
		return rf(ctx, coinID, minPay, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, float32, time.Time) []*model.PayoutForBlock); ok {
		r0 = rf(ctx, coinID, minPay, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutForBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, float32, time.Time) error); ok {
		r1 = rf(ctx, coinID, minPay, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_FindPayoutsForBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindPayoutsForBlock'
type MockPayouts_FindPayoutsForBlock_Call struct {
	*mock.Call
}

// FindPayoutsForBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - minPay float32
//   - timestamp time.Time
func (_e *MockPayouts_Expecter) FindPayoutsForBlock(ctx interface{}, coinID interface{}, minPay interface{}, timestamp interface{}) *MockPayouts_FindPayoutsForBlock_Call {
	return &MockPayouts_FindPayoutsForBlock_Call{Call: _e.mock.On("FindPayoutsForBlock", ctx, coinID, minPay, timestamp)}
}

func (_c *MockPayouts_FindPayoutsForBlock_Call) Run(run func(ctx context.Context, coinID int64, minPay float32, timestamp time.Time)) *MockPayouts_FindPayoutsForBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(float32), args[3].(time.Time))
	})
	return _c
}

func (_c *MockPayouts_FindPayoutsForBlock_Call) Return(_a0 []*model.PayoutForBlock, _a1 error) *MockPayouts_FindPayoutsForBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_FindPayoutsForBlock_Call) RunAndReturn(run func(context.Context, int64, float32, time.Time) ([]*model.PayoutForBlock, error)) *MockPayouts_FindPayoutsForBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetAveragePaid provides a mock function with given fields: ctx, queryParams
func (_m *MockPayouts) GetAveragePaid(ctx context.Context, queryParams model.AveragePaidQuery) (decimal.Decimal, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for GetAveragePaid")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AveragePaidQuery) (decimal.Decimal, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.AveragePaidQuery) decimal.Decimal); ok {
		r0 = rf(ctx, queryParams)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.AveragePaidQuery) error); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetAveragePaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAveragePaid'
type MockPayouts_GetAveragePaid_Call struct {
	*mock.Call
}

// GetAveragePaid is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams model.AveragePaidQuery
func (_e *MockPayouts_Expecter) GetAveragePaid(ctx interface{}, queryParams interface{}) *MockPayouts_GetAveragePaid_Call {
	return &MockPayouts_GetAveragePaid_Call{Call: _e.mock.On("GetAveragePaid", ctx, queryParams)}
}

func (_c *MockPayouts_GetAveragePaid_Call) Run(run func(ctx context.Context, queryParams model.AveragePaidQuery)) *MockPayouts_GetAveragePaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.AveragePaidQuery))
	})
	return _c
}

func (_c *MockPayouts_GetAveragePaid_Call) Return(_a0 decimal.Decimal, _a1 error) *MockPayouts_GetAveragePaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetAveragePaid_Call) RunAndReturn(run func(context.Context, model.AveragePaidQuery) (decimal.Decimal, error)) *MockPayouts_GetAveragePaid_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsBlock provides a mock function with given fields: ctx, coinID, username, isService
func (_m *MockPayouts) GetCurrentPayoutsBlock(ctx context.Context, coinID int64, username string, isService bool) ([]*model.PayoutBlockTransaction, error) {
	ret := _m.Called(ctx, coinID, username, isService)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsBlock")
	}

	var r0 []*model.PayoutBlockTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, bool) ([]*model.PayoutBlockTransaction, error)); ok {
		return rf(ctx, coinID, username, isService)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, bool) []*model.PayoutBlockTransaction); ok {
		r0 = rf(ctx, coinID, username, isService)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutBlockTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, bool) error); ok {
		r1 = rf(ctx, coinID, username, isService)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetCurrentPayoutsBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsBlock'
type MockPayouts_GetCurrentPayoutsBlock_Call struct {
	*mock.Call
}

// GetCurrentPayoutsBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - username string
//   - isService bool
func (_e *MockPayouts_Expecter) GetCurrentPayoutsBlock(ctx interface{}, coinID interface{}, username interface{}, isService interface{}) *MockPayouts_GetCurrentPayoutsBlock_Call {
	return &MockPayouts_GetCurrentPayoutsBlock_Call{Call: _e.mock.On("GetCurrentPayoutsBlock", ctx, coinID, username, isService)}
}

func (_c *MockPayouts_GetCurrentPayoutsBlock_Call) Run(run func(ctx context.Context, coinID int64, username string, isService bool)) *MockPayouts_GetCurrentPayoutsBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockPayouts_GetCurrentPayoutsBlock_Call) Return(_a0 []*model.PayoutBlockTransaction, _a1 error) *MockPayouts_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetCurrentPayoutsBlock_Call) RunAndReturn(run func(context.Context, int64, string, bool) ([]*model.PayoutBlockTransaction, error)) *MockPayouts_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsList provides a mock function with given fields: ctx, coinID, paymentTransactionType
func (_m *MockPayouts) GetCurrentPayoutsList(ctx context.Context, coinID int64, paymentTransactionType int64) ([]*model.PayoutWithCalculation, error) {
	ret := _m.Called(ctx, coinID, paymentTransactionType)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsList")
	}

	var r0 []*model.PayoutWithCalculation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) ([]*model.PayoutWithCalculation, error)); ok {
		return rf(ctx, coinID, paymentTransactionType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) []*model.PayoutWithCalculation); ok {
		r0 = rf(ctx, coinID, paymentTransactionType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutWithCalculation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, coinID, paymentTransactionType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetCurrentPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsList'
type MockPayouts_GetCurrentPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - paymentTransactionType int64
func (_e *MockPayouts_Expecter) GetCurrentPayoutsList(ctx interface{}, coinID interface{}, paymentTransactionType interface{}) *MockPayouts_GetCurrentPayoutsList_Call {
	return &MockPayouts_GetCurrentPayoutsList_Call{Call: _e.mock.On("GetCurrentPayoutsList", ctx, coinID, paymentTransactionType)}
}

func (_c *MockPayouts_GetCurrentPayoutsList_Call) Run(run func(ctx context.Context, coinID int64, paymentTransactionType int64)) *MockPayouts_GetCurrentPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockPayouts_GetCurrentPayoutsList_Call) Return(_a0 []*model.PayoutWithCalculation, _a1 error) *MockPayouts_GetCurrentPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetCurrentPayoutsList_Call) RunAndReturn(run func(context.Context, int64, int64) ([]*model.PayoutWithCalculation, error)) *MockPayouts_GetCurrentPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentReferralsPayoutsList provides a mock function with given fields: ctx, coinID, paymentTransactionType, referralId
func (_m *MockPayouts) GetCurrentReferralsPayoutsList(ctx context.Context, coinID int64, paymentTransactionType int64, referralId int64) ([]*model.PayoutWithCalculation, error) {
	ret := _m.Called(ctx, coinID, paymentTransactionType, referralId)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentReferralsPayoutsList")
	}

	var r0 []*model.PayoutWithCalculation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, int64) ([]*model.PayoutWithCalculation, error)); ok {
		return rf(ctx, coinID, paymentTransactionType, referralId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, int64) []*model.PayoutWithCalculation); ok {
		r0 = rf(ctx, coinID, paymentTransactionType, referralId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutWithCalculation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, int64) error); ok {
		r1 = rf(ctx, coinID, paymentTransactionType, referralId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetCurrentReferralsPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentReferralsPayoutsList'
type MockPayouts_GetCurrentReferralsPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentReferralsPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - paymentTransactionType int64
//   - referralId int64
func (_e *MockPayouts_Expecter) GetCurrentReferralsPayoutsList(ctx interface{}, coinID interface{}, paymentTransactionType interface{}, referralId interface{}) *MockPayouts_GetCurrentReferralsPayoutsList_Call {
	return &MockPayouts_GetCurrentReferralsPayoutsList_Call{Call: _e.mock.On("GetCurrentReferralsPayoutsList", ctx, coinID, paymentTransactionType, referralId)}
}

func (_c *MockPayouts_GetCurrentReferralsPayoutsList_Call) Run(run func(ctx context.Context, coinID int64, paymentTransactionType int64, referralId int64)) *MockPayouts_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPayouts_GetCurrentReferralsPayoutsList_Call) Return(_a0 []*model.PayoutWithCalculation, _a1 error) *MockPayouts_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetCurrentReferralsPayoutsList_Call) RunAndReturn(run func(context.Context, int64, int64, int64) ([]*model.PayoutWithCalculation, error)) *MockPayouts_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetFreePayouts provides a mock function with given fields: ctx, coinID
func (_m *MockPayouts) GetFreePayouts(ctx context.Context, coinID int64) ([]*model.FreePayout, error) {
	ret := _m.Called(ctx, coinID)

	if len(ret) == 0 {
		panic("no return value specified for GetFreePayouts")
	}

	var r0 []*model.FreePayout
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]*model.FreePayout, error)); ok {
		return rf(ctx, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []*model.FreePayout); ok {
		r0 = rf(ctx, coinID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.FreePayout)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetFreePayouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFreePayouts'
type MockPayouts_GetFreePayouts_Call struct {
	*mock.Call
}

// GetFreePayouts is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
func (_e *MockPayouts_Expecter) GetFreePayouts(ctx interface{}, coinID interface{}) *MockPayouts_GetFreePayouts_Call {
	return &MockPayouts_GetFreePayouts_Call{Call: _e.mock.On("GetFreePayouts", ctx, coinID)}
}

func (_c *MockPayouts_GetFreePayouts_Call) Run(run func(ctx context.Context, coinID int64)) *MockPayouts_GetFreePayouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPayouts_GetFreePayouts_Call) Return(_a0 []*model.FreePayout, _a1 error) *MockPayouts_GetFreePayouts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetFreePayouts_Call) RunAndReturn(run func(context.Context, int64) ([]*model.FreePayout, error)) *MockPayouts_GetFreePayouts_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceUserData provides a mock function with given fields: ctx, coinId, username, limit
func (_m *MockPayouts) GetServiceUserData(ctx context.Context, coinId int64, username string, limit int64) ([]*model.ServiceUserBlock, error) {
	ret := _m.Called(ctx, coinId, username, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceUserData")
	}

	var r0 []*model.ServiceUserBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64) ([]*model.ServiceUserBlock, error)); ok {
		return rf(ctx, coinId, username, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64) []*model.ServiceUserBlock); ok {
		r0 = rf(ctx, coinId, username, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.ServiceUserBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, int64) error); ok {
		r1 = rf(ctx, coinId, username, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayouts_GetServiceUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceUserData'
type MockPayouts_GetServiceUserData_Call struct {
	*mock.Call
}

// GetServiceUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - coinId int64
//   - username string
//   - limit int64
func (_e *MockPayouts_Expecter) GetServiceUserData(ctx interface{}, coinId interface{}, username interface{}, limit interface{}) *MockPayouts_GetServiceUserData_Call {
	return &MockPayouts_GetServiceUserData_Call{Call: _e.mock.On("GetServiceUserData", ctx, coinId, username, limit)}
}

func (_c *MockPayouts_GetServiceUserData_Call) Run(run func(ctx context.Context, coinId int64, username string, limit int64)) *MockPayouts_GetServiceUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockPayouts_GetServiceUserData_Call) Return(_a0 []*model.ServiceUserBlock, _a1 error) *MockPayouts_GetServiceUserData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayouts_GetServiceUserData_Call) RunAndReturn(run func(context.Context, int64, string, int64) ([]*model.ServiceUserBlock, error)) *MockPayouts_GetServiceUserData_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPayouts creates a new instance of MockPayouts. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPayouts(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPayouts {
	mock := &MockPayouts{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

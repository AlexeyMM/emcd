// Code generated by mockery v2.43.2. DO NOT EDIT.

package accounting

import (
	context "context"

	accounting "code.emcdtech.com/emcd/service/accounting/protocol/accounting"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// MockAccountingServiceClient is an autogenerated mock type for the AccountingServiceClient type
type MockAccountingServiceClient struct {
	mock.Mock
}

type MockAccountingServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountingServiceClient) EXPECT() *MockAccountingServiceClient_Expecter {
	return &MockAccountingServiceClient_Expecter{mock: &_m.Mock}
}

// ChangeBalance provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) ChangeBalance(ctx context.Context, in *accounting.ChangeBalanceRequest, opts ...grpc.CallOption) (*accounting.ChangeBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeBalance")
	}

	var r0 *accounting.ChangeBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ChangeBalanceRequest, ...grpc.CallOption) (*accounting.ChangeBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ChangeBalanceRequest, ...grpc.CallOption) *accounting.ChangeBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ChangeBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.ChangeBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_ChangeBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeBalance'
type MockAccountingServiceClient_ChangeBalance_Call struct {
	*mock.Call
}

// ChangeBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.ChangeBalanceRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) ChangeBalance(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_ChangeBalance_Call {
	return &MockAccountingServiceClient_ChangeBalance_Call{Call: _e.mock.On("ChangeBalance",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_ChangeBalance_Call) Run(run func(ctx context.Context, in *accounting.ChangeBalanceRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_ChangeBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.ChangeBalanceRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_ChangeBalance_Call) Return(_a0 *accounting.ChangeBalanceResponse, _a1 error) *MockAccountingServiceClient_ChangeBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_ChangeBalance_Call) RunAndReturn(run func(context.Context, *accounting.ChangeBalanceRequest, ...grpc.CallOption) (*accounting.ChangeBalanceResponse, error)) *MockAccountingServiceClient_ChangeBalance_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeMultipleBalance provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) ChangeMultipleBalance(ctx context.Context, in *accounting.ChangeMultipleBalanceRequest, opts ...grpc.CallOption) (*accounting.ChangeMultipleBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeMultipleBalance")
	}

	var r0 *accounting.ChangeMultipleBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ChangeMultipleBalanceRequest, ...grpc.CallOption) (*accounting.ChangeMultipleBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ChangeMultipleBalanceRequest, ...grpc.CallOption) *accounting.ChangeMultipleBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ChangeMultipleBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.ChangeMultipleBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_ChangeMultipleBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeMultipleBalance'
type MockAccountingServiceClient_ChangeMultipleBalance_Call struct {
	*mock.Call
}

// ChangeMultipleBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.ChangeMultipleBalanceRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) ChangeMultipleBalance(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_ChangeMultipleBalance_Call {
	return &MockAccountingServiceClient_ChangeMultipleBalance_Call{Call: _e.mock.On("ChangeMultipleBalance",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_ChangeMultipleBalance_Call) Run(run func(ctx context.Context, in *accounting.ChangeMultipleBalanceRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_ChangeMultipleBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.ChangeMultipleBalanceRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_ChangeMultipleBalance_Call) Return(_a0 *accounting.ChangeMultipleBalanceResponse, _a1 error) *MockAccountingServiceClient_ChangeMultipleBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_ChangeMultipleBalance_Call) RunAndReturn(run func(context.Context, *accounting.ChangeMultipleBalanceRequest, ...grpc.CallOption) (*accounting.ChangeMultipleBalanceResponse, error)) *MockAccountingServiceClient_ChangeMultipleBalance_Call {
	_c.Call.Return(run)
	return _c
}

// CheckFreePayoutTransaction provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) CheckFreePayoutTransaction(ctx context.Context, in *accounting.CheckFreePayoutTransactionRequest, opts ...grpc.CallOption) (*accounting.CheckFreePayoutTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckFreePayoutTransaction")
	}

	var r0 *accounting.CheckFreePayoutTransactionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckFreePayoutTransactionRequest, ...grpc.CallOption) (*accounting.CheckFreePayoutTransactionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckFreePayoutTransactionRequest, ...grpc.CallOption) *accounting.CheckFreePayoutTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.CheckFreePayoutTransactionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.CheckFreePayoutTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_CheckFreePayoutTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckFreePayoutTransaction'
type MockAccountingServiceClient_CheckFreePayoutTransaction_Call struct {
	*mock.Call
}

// CheckFreePayoutTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.CheckFreePayoutTransactionRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) CheckFreePayoutTransaction(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_CheckFreePayoutTransaction_Call {
	return &MockAccountingServiceClient_CheckFreePayoutTransaction_Call{Call: _e.mock.On("CheckFreePayoutTransaction",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_CheckFreePayoutTransaction_Call) Run(run func(ctx context.Context, in *accounting.CheckFreePayoutTransactionRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_CheckFreePayoutTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.CheckFreePayoutTransactionRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_CheckFreePayoutTransaction_Call) Return(_a0 *accounting.CheckFreePayoutTransactionResponse, _a1 error) *MockAccountingServiceClient_CheckFreePayoutTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_CheckFreePayoutTransaction_Call) RunAndReturn(run func(context.Context, *accounting.CheckFreePayoutTransactionRequest, ...grpc.CallOption) (*accounting.CheckFreePayoutTransactionResponse, error)) *MockAccountingServiceClient_CheckFreePayoutTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIncomeOperations provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) CheckIncomeOperations(ctx context.Context, in *accounting.CheckIncomeOperationsRequest, opts ...grpc.CallOption) (*accounting.CheckIncomeOperationsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckIncomeOperations")
	}

	var r0 *accounting.CheckIncomeOperationsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckIncomeOperationsRequest, ...grpc.CallOption) (*accounting.CheckIncomeOperationsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckIncomeOperationsRequest, ...grpc.CallOption) *accounting.CheckIncomeOperationsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.CheckIncomeOperationsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.CheckIncomeOperationsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_CheckIncomeOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIncomeOperations'
type MockAccountingServiceClient_CheckIncomeOperations_Call struct {
	*mock.Call
}

// CheckIncomeOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.CheckIncomeOperationsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) CheckIncomeOperations(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_CheckIncomeOperations_Call {
	return &MockAccountingServiceClient_CheckIncomeOperations_Call{Call: _e.mock.On("CheckIncomeOperations",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_CheckIncomeOperations_Call) Run(run func(ctx context.Context, in *accounting.CheckIncomeOperationsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_CheckIncomeOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.CheckIncomeOperationsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_CheckIncomeOperations_Call) Return(_a0 *accounting.CheckIncomeOperationsResponse, _a1 error) *MockAccountingServiceClient_CheckIncomeOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_CheckIncomeOperations_Call) RunAndReturn(run func(context.Context, *accounting.CheckIncomeOperationsRequest, ...grpc.CallOption) (*accounting.CheckIncomeOperationsResponse, error)) *MockAccountingServiceClient_CheckIncomeOperations_Call {
	_c.Call.Return(run)
	return _c
}

// CheckOthers provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) CheckOthers(ctx context.Context, in *accounting.CheckOthersRequest, opts ...grpc.CallOption) (*accounting.CheckOthersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckOthers")
	}

	var r0 *accounting.CheckOthersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckOthersRequest, ...grpc.CallOption) (*accounting.CheckOthersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckOthersRequest, ...grpc.CallOption) *accounting.CheckOthersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.CheckOthersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.CheckOthersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_CheckOthers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckOthers'
type MockAccountingServiceClient_CheckOthers_Call struct {
	*mock.Call
}

// CheckOthers is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.CheckOthersRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) CheckOthers(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_CheckOthers_Call {
	return &MockAccountingServiceClient_CheckOthers_Call{Call: _e.mock.On("CheckOthers",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_CheckOthers_Call) Run(run func(ctx context.Context, in *accounting.CheckOthersRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_CheckOthers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.CheckOthersRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_CheckOthers_Call) Return(_a0 *accounting.CheckOthersResponse, _a1 error) *MockAccountingServiceClient_CheckOthers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_CheckOthers_Call) RunAndReturn(run func(context.Context, *accounting.CheckOthersRequest, ...grpc.CallOption) (*accounting.CheckOthersResponse, error)) *MockAccountingServiceClient_CheckOthers_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPayoutBlockStatus provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) CheckPayoutBlockStatus(ctx context.Context, in *accounting.CheckPayoutBlockStatusRequest, opts ...grpc.CallOption) (*accounting.CheckPayoutBlockStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayoutBlockStatus")
	}

	var r0 *accounting.CheckPayoutBlockStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckPayoutBlockStatusRequest, ...grpc.CallOption) (*accounting.CheckPayoutBlockStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckPayoutBlockStatusRequest, ...grpc.CallOption) *accounting.CheckPayoutBlockStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.CheckPayoutBlockStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.CheckPayoutBlockStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_CheckPayoutBlockStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPayoutBlockStatus'
type MockAccountingServiceClient_CheckPayoutBlockStatus_Call struct {
	*mock.Call
}

// CheckPayoutBlockStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.CheckPayoutBlockStatusRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) CheckPayoutBlockStatus(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_CheckPayoutBlockStatus_Call {
	return &MockAccountingServiceClient_CheckPayoutBlockStatus_Call{Call: _e.mock.On("CheckPayoutBlockStatus",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_CheckPayoutBlockStatus_Call) Run(run func(ctx context.Context, in *accounting.CheckPayoutBlockStatusRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_CheckPayoutBlockStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.CheckPayoutBlockStatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_CheckPayoutBlockStatus_Call) Return(_a0 *accounting.CheckPayoutBlockStatusResponse, _a1 error) *MockAccountingServiceClient_CheckPayoutBlockStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_CheckPayoutBlockStatus_Call) RunAndReturn(run func(context.Context, *accounting.CheckPayoutBlockStatusRequest, ...grpc.CallOption) (*accounting.CheckPayoutBlockStatusResponse, error)) *MockAccountingServiceClient_CheckPayoutBlockStatus_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPayoutsLimit provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) CheckPayoutsLimit(ctx context.Context, in *accounting.CheckPayoutsLimitRequest, opts ...grpc.CallOption) (*accounting.CheckPayoutsLimitResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayoutsLimit")
	}

	var r0 *accounting.CheckPayoutsLimitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckPayoutsLimitRequest, ...grpc.CallOption) (*accounting.CheckPayoutsLimitResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.CheckPayoutsLimitRequest, ...grpc.CallOption) *accounting.CheckPayoutsLimitResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.CheckPayoutsLimitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.CheckPayoutsLimitRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_CheckPayoutsLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPayoutsLimit'
type MockAccountingServiceClient_CheckPayoutsLimit_Call struct {
	*mock.Call
}

// CheckPayoutsLimit is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.CheckPayoutsLimitRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) CheckPayoutsLimit(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_CheckPayoutsLimit_Call {
	return &MockAccountingServiceClient_CheckPayoutsLimit_Call{Call: _e.mock.On("CheckPayoutsLimit",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_CheckPayoutsLimit_Call) Run(run func(ctx context.Context, in *accounting.CheckPayoutsLimitRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_CheckPayoutsLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.CheckPayoutsLimitRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_CheckPayoutsLimit_Call) Return(_a0 *accounting.CheckPayoutsLimitResponse, _a1 error) *MockAccountingServiceClient_CheckPayoutsLimit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_CheckPayoutsLimit_Call) RunAndReturn(run func(context.Context, *accounting.CheckPayoutsLimitRequest, ...grpc.CallOption) (*accounting.CheckPayoutsLimitResponse, error)) *MockAccountingServiceClient_CheckPayoutsLimit_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffMining provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindBalancesDiffMining(ctx context.Context, in *accounting.FindBalancesDiffMiningRequest, opts ...grpc.CallOption) (*accounting.FindBalancesDiffMiningResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffMining")
	}

	var r0 *accounting.FindBalancesDiffMiningResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBalancesDiffMiningRequest, ...grpc.CallOption) (*accounting.FindBalancesDiffMiningResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBalancesDiffMiningRequest, ...grpc.CallOption) *accounting.FindBalancesDiffMiningResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindBalancesDiffMiningResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindBalancesDiffMiningRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindBalancesDiffMining_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffMining'
type MockAccountingServiceClient_FindBalancesDiffMining_Call struct {
	*mock.Call
}

// FindBalancesDiffMining is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindBalancesDiffMiningRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindBalancesDiffMining(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindBalancesDiffMining_Call {
	return &MockAccountingServiceClient_FindBalancesDiffMining_Call{Call: _e.mock.On("FindBalancesDiffMining",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindBalancesDiffMining_Call) Run(run func(ctx context.Context, in *accounting.FindBalancesDiffMiningRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindBalancesDiffMining_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindBalancesDiffMiningRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindBalancesDiffMining_Call) Return(_a0 *accounting.FindBalancesDiffMiningResponse, _a1 error) *MockAccountingServiceClient_FindBalancesDiffMining_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindBalancesDiffMining_Call) RunAndReturn(run func(context.Context, *accounting.FindBalancesDiffMiningRequest, ...grpc.CallOption) (*accounting.FindBalancesDiffMiningResponse, error)) *MockAccountingServiceClient_FindBalancesDiffMining_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffWallet provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindBalancesDiffWallet(ctx context.Context, in *accounting.FindBalancesDiffWalletRequest, opts ...grpc.CallOption) (*accounting.FindBalancesDiffWalletResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffWallet")
	}

	var r0 *accounting.FindBalancesDiffWalletResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBalancesDiffWalletRequest, ...grpc.CallOption) (*accounting.FindBalancesDiffWalletResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBalancesDiffWalletRequest, ...grpc.CallOption) *accounting.FindBalancesDiffWalletResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindBalancesDiffWalletResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindBalancesDiffWalletRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindBalancesDiffWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffWallet'
type MockAccountingServiceClient_FindBalancesDiffWallet_Call struct {
	*mock.Call
}

// FindBalancesDiffWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindBalancesDiffWalletRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindBalancesDiffWallet(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindBalancesDiffWallet_Call {
	return &MockAccountingServiceClient_FindBalancesDiffWallet_Call{Call: _e.mock.On("FindBalancesDiffWallet",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindBalancesDiffWallet_Call) Run(run func(ctx context.Context, in *accounting.FindBalancesDiffWalletRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindBalancesDiffWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindBalancesDiffWalletRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindBalancesDiffWallet_Call) Return(_a0 *accounting.FindBalancesDiffWalletResponse, _a1 error) *MockAccountingServiceClient_FindBalancesDiffWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindBalancesDiffWallet_Call) RunAndReturn(run func(context.Context, *accounting.FindBalancesDiffWalletRequest, ...grpc.CallOption) (*accounting.FindBalancesDiffWalletResponse, error)) *MockAccountingServiceClient_FindBalancesDiffWallet_Call {
	_c.Call.Return(run)
	return _c
}

// FindBatchOperations provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindBatchOperations(ctx context.Context, in *accounting.FindBatchOperationsRequest, opts ...grpc.CallOption) (*accounting.FindBatchOperationsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindBatchOperations")
	}

	var r0 *accounting.FindBatchOperationsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBatchOperationsRequest, ...grpc.CallOption) (*accounting.FindBatchOperationsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindBatchOperationsRequest, ...grpc.CallOption) *accounting.FindBatchOperationsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindBatchOperationsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindBatchOperationsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindBatchOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBatchOperations'
type MockAccountingServiceClient_FindBatchOperations_Call struct {
	*mock.Call
}

// FindBatchOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindBatchOperationsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindBatchOperations(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindBatchOperations_Call {
	return &MockAccountingServiceClient_FindBatchOperations_Call{Call: _e.mock.On("FindBatchOperations",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindBatchOperations_Call) Run(run func(ctx context.Context, in *accounting.FindBatchOperationsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindBatchOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindBatchOperationsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindBatchOperations_Call) Return(_a0 *accounting.FindBatchOperationsResponse, _a1 error) *MockAccountingServiceClient_FindBatchOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindBatchOperations_Call) RunAndReturn(run func(context.Context, *accounting.FindBatchOperationsRequest, ...grpc.CallOption) (*accounting.FindBatchOperationsResponse, error)) *MockAccountingServiceClient_FindBatchOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindLastBlockTimeBalances provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindLastBlockTimeBalances(ctx context.Context, in *accounting.FindLastBlockTimeBalancesRequest, opts ...grpc.CallOption) (*accounting.FindLastBlockTimeBalancesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindLastBlockTimeBalances")
	}

	var r0 *accounting.FindLastBlockTimeBalancesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindLastBlockTimeBalancesRequest, ...grpc.CallOption) (*accounting.FindLastBlockTimeBalancesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindLastBlockTimeBalancesRequest, ...grpc.CallOption) *accounting.FindLastBlockTimeBalancesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindLastBlockTimeBalancesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindLastBlockTimeBalancesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindLastBlockTimeBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindLastBlockTimeBalances'
type MockAccountingServiceClient_FindLastBlockTimeBalances_Call struct {
	*mock.Call
}

// FindLastBlockTimeBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindLastBlockTimeBalancesRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindLastBlockTimeBalances(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindLastBlockTimeBalances_Call {
	return &MockAccountingServiceClient_FindLastBlockTimeBalances_Call{Call: _e.mock.On("FindLastBlockTimeBalances",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindLastBlockTimeBalances_Call) Run(run func(ctx context.Context, in *accounting.FindLastBlockTimeBalancesRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindLastBlockTimeBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindLastBlockTimeBalancesRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindLastBlockTimeBalances_Call) Return(_a0 *accounting.FindLastBlockTimeBalancesResponse, _a1 error) *MockAccountingServiceClient_FindLastBlockTimeBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindLastBlockTimeBalances_Call) RunAndReturn(run func(context.Context, *accounting.FindLastBlockTimeBalancesRequest, ...grpc.CallOption) (*accounting.FindLastBlockTimeBalancesResponse, error)) *MockAccountingServiceClient_FindLastBlockTimeBalances_Call {
	_c.Call.Return(run)
	return _c
}

// FindOperations provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindOperations(ctx context.Context, in *accounting.FindOperationsRequest, opts ...grpc.CallOption) (*accounting.FindOperationsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindOperations")
	}

	var r0 *accounting.FindOperationsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindOperationsRequest, ...grpc.CallOption) (*accounting.FindOperationsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindOperationsRequest, ...grpc.CallOption) *accounting.FindOperationsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindOperationsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindOperationsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOperations'
type MockAccountingServiceClient_FindOperations_Call struct {
	*mock.Call
}

// FindOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindOperationsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindOperations(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindOperations_Call {
	return &MockAccountingServiceClient_FindOperations_Call{Call: _e.mock.On("FindOperations",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindOperations_Call) Run(run func(ctx context.Context, in *accounting.FindOperationsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindOperationsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindOperations_Call) Return(_a0 *accounting.FindOperationsResponse, _a1 error) *MockAccountingServiceClient_FindOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindOperations_Call) RunAndReturn(run func(context.Context, *accounting.FindOperationsRequest, ...grpc.CallOption) (*accounting.FindOperationsResponse, error)) *MockAccountingServiceClient_FindOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindOperationsAndTransactions provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindOperationsAndTransactions(ctx context.Context, in *accounting.FindOperationsAndTransactionsRequest, opts ...grpc.CallOption) (*accounting.FindOperationsAndTransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindOperationsAndTransactions")
	}

	var r0 *accounting.FindOperationsAndTransactionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindOperationsAndTransactionsRequest, ...grpc.CallOption) (*accounting.FindOperationsAndTransactionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindOperationsAndTransactionsRequest, ...grpc.CallOption) *accounting.FindOperationsAndTransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindOperationsAndTransactionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindOperationsAndTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindOperationsAndTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOperationsAndTransactions'
type MockAccountingServiceClient_FindOperationsAndTransactions_Call struct {
	*mock.Call
}

// FindOperationsAndTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindOperationsAndTransactionsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindOperationsAndTransactions(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindOperationsAndTransactions_Call {
	return &MockAccountingServiceClient_FindOperationsAndTransactions_Call{Call: _e.mock.On("FindOperationsAndTransactions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindOperationsAndTransactions_Call) Run(run func(ctx context.Context, in *accounting.FindOperationsAndTransactionsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindOperationsAndTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindOperationsAndTransactionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindOperationsAndTransactions_Call) Return(_a0 *accounting.FindOperationsAndTransactionsResponse, _a1 error) *MockAccountingServiceClient_FindOperationsAndTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindOperationsAndTransactions_Call) RunAndReturn(run func(context.Context, *accounting.FindOperationsAndTransactionsRequest, ...grpc.CallOption) (*accounting.FindOperationsAndTransactionsResponse, error)) *MockAccountingServiceClient_FindOperationsAndTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// FindPayoutsForBlock provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindPayoutsForBlock(ctx context.Context, in *accounting.FindPayoutsForBlockRequest, opts ...grpc.CallOption) (*accounting.FindPayoutsForBlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindPayoutsForBlock")
	}

	var r0 *accounting.FindPayoutsForBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindPayoutsForBlockRequest, ...grpc.CallOption) (*accounting.FindPayoutsForBlockResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindPayoutsForBlockRequest, ...grpc.CallOption) *accounting.FindPayoutsForBlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindPayoutsForBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindPayoutsForBlockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindPayoutsForBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindPayoutsForBlock'
type MockAccountingServiceClient_FindPayoutsForBlock_Call struct {
	*mock.Call
}

// FindPayoutsForBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindPayoutsForBlockRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindPayoutsForBlock(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindPayoutsForBlock_Call {
	return &MockAccountingServiceClient_FindPayoutsForBlock_Call{Call: _e.mock.On("FindPayoutsForBlock",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindPayoutsForBlock_Call) Run(run func(ctx context.Context, in *accounting.FindPayoutsForBlockRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindPayoutsForBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindPayoutsForBlockRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindPayoutsForBlock_Call) Return(_a0 *accounting.FindPayoutsForBlockResponse, _a1 error) *MockAccountingServiceClient_FindPayoutsForBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindPayoutsForBlock_Call) RunAndReturn(run func(context.Context, *accounting.FindPayoutsForBlockRequest, ...grpc.CallOption) (*accounting.FindPayoutsForBlockResponse, error)) *MockAccountingServiceClient_FindPayoutsForBlock_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactions provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindTransactions(ctx context.Context, in *accounting.FindTransactionsRequest, opts ...grpc.CallOption) (*accounting.FindTransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactions")
	}

	var r0 *accounting.FindTransactionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindTransactionsRequest, ...grpc.CallOption) (*accounting.FindTransactionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindTransactionsRequest, ...grpc.CallOption) *accounting.FindTransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindTransactionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactions'
type MockAccountingServiceClient_FindTransactions_Call struct {
	*mock.Call
}

// FindTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindTransactionsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindTransactions(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindTransactions_Call {
	return &MockAccountingServiceClient_FindTransactions_Call{Call: _e.mock.On("FindTransactions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindTransactions_Call) Run(run func(ctx context.Context, in *accounting.FindTransactionsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindTransactionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactions_Call) Return(_a0 *accounting.FindTransactionsResponse, _a1 error) *MockAccountingServiceClient_FindTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactions_Call) RunAndReturn(run func(context.Context, *accounting.FindTransactionsRequest, ...grpc.CallOption) (*accounting.FindTransactionsResponse, error)) *MockAccountingServiceClient_FindTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactionsByCollectorFilter provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindTransactionsByCollectorFilter(ctx context.Context, in *accounting.TransactionCollectorFilter, opts ...grpc.CallOption) (*accounting.TransactionMultiResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactionsByCollectorFilter")
	}

	var r0 *accounting.TransactionMultiResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.TransactionCollectorFilter, ...grpc.CallOption) (*accounting.TransactionMultiResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.TransactionCollectorFilter, ...grpc.CallOption) *accounting.TransactionMultiResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.TransactionMultiResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.TransactionCollectorFilter, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactionsByCollectorFilter'
type MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call struct {
	*mock.Call
}

// FindTransactionsByCollectorFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.TransactionCollectorFilter
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindTransactionsByCollectorFilter(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call {
	return &MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call{Call: _e.mock.On("FindTransactionsByCollectorFilter",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call) Run(run func(ctx context.Context, in *accounting.TransactionCollectorFilter, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.TransactionCollectorFilter), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call) Return(_a0 *accounting.TransactionMultiResponse, _a1 error) *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call) RunAndReturn(run func(context.Context, *accounting.TransactionCollectorFilter, ...grpc.CallOption) (*accounting.TransactionMultiResponse, error)) *MockAccountingServiceClient_FindTransactionsByCollectorFilter_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactionsWithBlocks provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) FindTransactionsWithBlocks(ctx context.Context, in *accounting.FindTransactionsWithBlocksRequest, opts ...grpc.CallOption) (*accounting.FindTransactionsWithBlocksResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactionsWithBlocks")
	}

	var r0 *accounting.FindTransactionsWithBlocksResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindTransactionsWithBlocksRequest, ...grpc.CallOption) (*accounting.FindTransactionsWithBlocksResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.FindTransactionsWithBlocksRequest, ...grpc.CallOption) *accounting.FindTransactionsWithBlocksResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.FindTransactionsWithBlocksResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.FindTransactionsWithBlocksRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_FindTransactionsWithBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactionsWithBlocks'
type MockAccountingServiceClient_FindTransactionsWithBlocks_Call struct {
	*mock.Call
}

// FindTransactionsWithBlocks is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.FindTransactionsWithBlocksRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) FindTransactionsWithBlocks(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_FindTransactionsWithBlocks_Call {
	return &MockAccountingServiceClient_FindTransactionsWithBlocks_Call{Call: _e.mock.On("FindTransactionsWithBlocks",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_FindTransactionsWithBlocks_Call) Run(run func(ctx context.Context, in *accounting.FindTransactionsWithBlocksRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_FindTransactionsWithBlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.FindTransactionsWithBlocksRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactionsWithBlocks_Call) Return(_a0 *accounting.FindTransactionsWithBlocksResponse, _a1 error) *MockAccountingServiceClient_FindTransactionsWithBlocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_FindTransactionsWithBlocks_Call) RunAndReturn(run func(context.Context, *accounting.FindTransactionsWithBlocksRequest, ...grpc.CallOption) (*accounting.FindTransactionsWithBlocksResponse, error)) *MockAccountingServiceClient_FindTransactionsWithBlocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetAveragePaid provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetAveragePaid(ctx context.Context, in *accounting.GetAveragePaidRequest, opts ...grpc.CallOption) (*accounting.GetAveragePaidResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAveragePaid")
	}

	var r0 *accounting.GetAveragePaidResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetAveragePaidRequest, ...grpc.CallOption) (*accounting.GetAveragePaidResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetAveragePaidRequest, ...grpc.CallOption) *accounting.GetAveragePaidResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetAveragePaidResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetAveragePaidRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetAveragePaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAveragePaid'
type MockAccountingServiceClient_GetAveragePaid_Call struct {
	*mock.Call
}

// GetAveragePaid is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetAveragePaidRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetAveragePaid(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetAveragePaid_Call {
	return &MockAccountingServiceClient_GetAveragePaid_Call{Call: _e.mock.On("GetAveragePaid",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetAveragePaid_Call) Run(run func(ctx context.Context, in *accounting.GetAveragePaidRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetAveragePaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetAveragePaidRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetAveragePaid_Call) Return(_a0 *accounting.GetAveragePaidResponse, _a1 error) *MockAccountingServiceClient_GetAveragePaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetAveragePaid_Call) RunAndReturn(run func(context.Context, *accounting.GetAveragePaidRequest, ...grpc.CallOption) (*accounting.GetAveragePaidResponse, error)) *MockAccountingServiceClient_GetAveragePaid_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalanceBeforeTransaction provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetBalanceBeforeTransaction(ctx context.Context, in *accounting.GetBalanceBeforeTransactionRequest, opts ...grpc.CallOption) (*accounting.GetBalanceBeforeTransactionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBalanceBeforeTransaction")
	}

	var r0 *accounting.GetBalanceBeforeTransactionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetBalanceBeforeTransactionRequest, ...grpc.CallOption) (*accounting.GetBalanceBeforeTransactionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetBalanceBeforeTransactionRequest, ...grpc.CallOption) *accounting.GetBalanceBeforeTransactionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetBalanceBeforeTransactionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetBalanceBeforeTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetBalanceBeforeTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalanceBeforeTransaction'
type MockAccountingServiceClient_GetBalanceBeforeTransaction_Call struct {
	*mock.Call
}

// GetBalanceBeforeTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetBalanceBeforeTransactionRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetBalanceBeforeTransaction(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call {
	return &MockAccountingServiceClient_GetBalanceBeforeTransaction_Call{Call: _e.mock.On("GetBalanceBeforeTransaction",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call) Run(run func(ctx context.Context, in *accounting.GetBalanceBeforeTransactionRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetBalanceBeforeTransactionRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call) Return(_a0 *accounting.GetBalanceBeforeTransactionResponse, _a1 error) *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call) RunAndReturn(run func(context.Context, *accounting.GetBalanceBeforeTransactionRequest, ...grpc.CallOption) (*accounting.GetBalanceBeforeTransactionResponse, error)) *MockAccountingServiceClient_GetBalanceBeforeTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalanceByCoin provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetBalanceByCoin(ctx context.Context, in *accounting.GetBalanceByCoinRequest, opts ...grpc.CallOption) (*accounting.GetBalanceByCoinResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBalanceByCoin")
	}

	var r0 *accounting.GetBalanceByCoinResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetBalanceByCoinRequest, ...grpc.CallOption) (*accounting.GetBalanceByCoinResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetBalanceByCoinRequest, ...grpc.CallOption) *accounting.GetBalanceByCoinResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetBalanceByCoinResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetBalanceByCoinRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetBalanceByCoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalanceByCoin'
type MockAccountingServiceClient_GetBalanceByCoin_Call struct {
	*mock.Call
}

// GetBalanceByCoin is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetBalanceByCoinRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetBalanceByCoin(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetBalanceByCoin_Call {
	return &MockAccountingServiceClient_GetBalanceByCoin_Call{Call: _e.mock.On("GetBalanceByCoin",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetBalanceByCoin_Call) Run(run func(ctx context.Context, in *accounting.GetBalanceByCoinRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetBalanceByCoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetBalanceByCoinRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetBalanceByCoin_Call) Return(_a0 *accounting.GetBalanceByCoinResponse, _a1 error) *MockAccountingServiceClient_GetBalanceByCoin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetBalanceByCoin_Call) RunAndReturn(run func(context.Context, *accounting.GetBalanceByCoinRequest, ...grpc.CallOption) (*accounting.GetBalanceByCoinResponse, error)) *MockAccountingServiceClient_GetBalanceByCoin_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalances provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetBalances(ctx context.Context, in *accounting.UserIDRequest, opts ...grpc.CallOption) (*accounting.GetBalancesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBalances")
	}

	var r0 *accounting.GetBalancesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) (*accounting.GetBalancesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) *accounting.GetBalancesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetBalancesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalances'
type MockAccountingServiceClient_GetBalances_Call struct {
	*mock.Call
}

// GetBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.UserIDRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetBalances(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetBalances_Call {
	return &MockAccountingServiceClient_GetBalances_Call{Call: _e.mock.On("GetBalances",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetBalances_Call) Run(run func(ctx context.Context, in *accounting.UserIDRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.UserIDRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetBalances_Call) Return(_a0 *accounting.GetBalancesResponse, _a1 error) *MockAccountingServiceClient_GetBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetBalances_Call) RunAndReturn(run func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) (*accounting.GetBalancesResponse, error)) *MockAccountingServiceClient_GetBalances_Call {
	_c.Call.Return(run)
	return _c
}

// GetCheckFreezePayoutsBlocks provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCheckFreezePayoutsBlocks(ctx context.Context, in *accounting.GetCheckFreezePayoutsBlocksRequest, opts ...grpc.CallOption) (*accounting.GetCheckFreezePayoutsBlocksResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCheckFreezePayoutsBlocks")
	}

	var r0 *accounting.GetCheckFreezePayoutsBlocksResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCheckFreezePayoutsBlocksRequest, ...grpc.CallOption) (*accounting.GetCheckFreezePayoutsBlocksResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCheckFreezePayoutsBlocksRequest, ...grpc.CallOption) *accounting.GetCheckFreezePayoutsBlocksResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCheckFreezePayoutsBlocksResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCheckFreezePayoutsBlocksRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCheckFreezePayoutsBlocks'
type MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call struct {
	*mock.Call
}

// GetCheckFreezePayoutsBlocks is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCheckFreezePayoutsBlocksRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCheckFreezePayoutsBlocks(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call {
	return &MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call{Call: _e.mock.On("GetCheckFreezePayoutsBlocks",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call) Run(run func(ctx context.Context, in *accounting.GetCheckFreezePayoutsBlocksRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCheckFreezePayoutsBlocksRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call) Return(_a0 *accounting.GetCheckFreezePayoutsBlocksResponse, _a1 error) *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call) RunAndReturn(run func(context.Context, *accounting.GetCheckFreezePayoutsBlocksRequest, ...grpc.CallOption) (*accounting.GetCheckFreezePayoutsBlocksResponse, error)) *MockAccountingServiceClient_GetCheckFreezePayoutsBlocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetCheckTransactionCoins provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCheckTransactionCoins(ctx context.Context, in *accounting.GetCheckTransactionCoinsRequest, opts ...grpc.CallOption) (*accounting.GetCheckTransactionCoinsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCheckTransactionCoins")
	}

	var r0 *accounting.GetCheckTransactionCoinsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCheckTransactionCoinsRequest, ...grpc.CallOption) (*accounting.GetCheckTransactionCoinsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCheckTransactionCoinsRequest, ...grpc.CallOption) *accounting.GetCheckTransactionCoinsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCheckTransactionCoinsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCheckTransactionCoinsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCheckTransactionCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCheckTransactionCoins'
type MockAccountingServiceClient_GetCheckTransactionCoins_Call struct {
	*mock.Call
}

// GetCheckTransactionCoins is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCheckTransactionCoinsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCheckTransactionCoins(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCheckTransactionCoins_Call {
	return &MockAccountingServiceClient_GetCheckTransactionCoins_Call{Call: _e.mock.On("GetCheckTransactionCoins",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCheckTransactionCoins_Call) Run(run func(ctx context.Context, in *accounting.GetCheckTransactionCoinsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCheckTransactionCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCheckTransactionCoinsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCheckTransactionCoins_Call) Return(_a0 *accounting.GetCheckTransactionCoinsResponse, _a1 error) *MockAccountingServiceClient_GetCheckTransactionCoins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCheckTransactionCoins_Call) RunAndReturn(run func(context.Context, *accounting.GetCheckTransactionCoinsRequest, ...grpc.CallOption) (*accounting.GetCheckTransactionCoinsResponse, error)) *MockAccountingServiceClient_GetCheckTransactionCoins_Call {
	_c.Call.Return(run)
	return _c
}

// GetCoinsOperationsSum provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCoinsOperationsSum(ctx context.Context, in *accounting.GetCoinsOperationsSumRequest, opts ...grpc.CallOption) (*accounting.GetCoinsOperationsSumResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCoinsOperationsSum")
	}

	var r0 *accounting.GetCoinsOperationsSumResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCoinsOperationsSumRequest, ...grpc.CallOption) (*accounting.GetCoinsOperationsSumResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCoinsOperationsSumRequest, ...grpc.CallOption) *accounting.GetCoinsOperationsSumResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCoinsOperationsSumResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCoinsOperationsSumRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCoinsOperationsSum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoinsOperationsSum'
type MockAccountingServiceClient_GetCoinsOperationsSum_Call struct {
	*mock.Call
}

// GetCoinsOperationsSum is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCoinsOperationsSumRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCoinsOperationsSum(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCoinsOperationsSum_Call {
	return &MockAccountingServiceClient_GetCoinsOperationsSum_Call{Call: _e.mock.On("GetCoinsOperationsSum",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCoinsOperationsSum_Call) Run(run func(ctx context.Context, in *accounting.GetCoinsOperationsSumRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCoinsOperationsSum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCoinsOperationsSumRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCoinsOperationsSum_Call) Return(_a0 *accounting.GetCoinsOperationsSumResponse, _a1 error) *MockAccountingServiceClient_GetCoinsOperationsSum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCoinsOperationsSum_Call) RunAndReturn(run func(context.Context, *accounting.GetCoinsOperationsSumRequest, ...grpc.CallOption) (*accounting.GetCoinsOperationsSumResponse, error)) *MockAccountingServiceClient_GetCoinsOperationsSum_Call {
	_c.Call.Return(run)
	return _c
}

// GetCoinsSummary provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCoinsSummary(ctx context.Context, in *accounting.UserIDRequest, opts ...grpc.CallOption) (*accounting.GetCoinsSummaryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCoinsSummary")
	}

	var r0 *accounting.GetCoinsSummaryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) (*accounting.GetCoinsSummaryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) *accounting.GetCoinsSummaryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCoinsSummaryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCoinsSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoinsSummary'
type MockAccountingServiceClient_GetCoinsSummary_Call struct {
	*mock.Call
}

// GetCoinsSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.UserIDRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCoinsSummary(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCoinsSummary_Call {
	return &MockAccountingServiceClient_GetCoinsSummary_Call{Call: _e.mock.On("GetCoinsSummary",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCoinsSummary_Call) Run(run func(ctx context.Context, in *accounting.UserIDRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCoinsSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.UserIDRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCoinsSummary_Call) Return(_a0 *accounting.GetCoinsSummaryResponse, _a1 error) *MockAccountingServiceClient_GetCoinsSummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCoinsSummary_Call) RunAndReturn(run func(context.Context, *accounting.UserIDRequest, ...grpc.CallOption) (*accounting.GetCoinsSummaryResponse, error)) *MockAccountingServiceClient_GetCoinsSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsBlock provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCurrentPayoutsBlock(ctx context.Context, in *accounting.GetCurrentPayoutsBlockRequest, opts ...grpc.CallOption) (*accounting.GetCurrentPayoutsBlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsBlock")
	}

	var r0 *accounting.GetCurrentPayoutsBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentPayoutsBlockRequest, ...grpc.CallOption) (*accounting.GetCurrentPayoutsBlockResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentPayoutsBlockRequest, ...grpc.CallOption) *accounting.GetCurrentPayoutsBlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCurrentPayoutsBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCurrentPayoutsBlockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCurrentPayoutsBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsBlock'
type MockAccountingServiceClient_GetCurrentPayoutsBlock_Call struct {
	*mock.Call
}

// GetCurrentPayoutsBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCurrentPayoutsBlockRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCurrentPayoutsBlock(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call {
	return &MockAccountingServiceClient_GetCurrentPayoutsBlock_Call{Call: _e.mock.On("GetCurrentPayoutsBlock",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call) Run(run func(ctx context.Context, in *accounting.GetCurrentPayoutsBlockRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCurrentPayoutsBlockRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call) Return(_a0 *accounting.GetCurrentPayoutsBlockResponse, _a1 error) *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call) RunAndReturn(run func(context.Context, *accounting.GetCurrentPayoutsBlockRequest, ...grpc.CallOption) (*accounting.GetCurrentPayoutsBlockResponse, error)) *MockAccountingServiceClient_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsList provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCurrentPayoutsList(ctx context.Context, in *accounting.GetCurrentPayoutsListRequest, opts ...grpc.CallOption) (*accounting.GetCurrentPayoutsListResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsList")
	}

	var r0 *accounting.GetCurrentPayoutsListResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentPayoutsListRequest, ...grpc.CallOption) (*accounting.GetCurrentPayoutsListResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentPayoutsListRequest, ...grpc.CallOption) *accounting.GetCurrentPayoutsListResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCurrentPayoutsListResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCurrentPayoutsListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCurrentPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsList'
type MockAccountingServiceClient_GetCurrentPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCurrentPayoutsListRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCurrentPayoutsList(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCurrentPayoutsList_Call {
	return &MockAccountingServiceClient_GetCurrentPayoutsList_Call{Call: _e.mock.On("GetCurrentPayoutsList",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsList_Call) Run(run func(ctx context.Context, in *accounting.GetCurrentPayoutsListRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCurrentPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCurrentPayoutsListRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsList_Call) Return(_a0 *accounting.GetCurrentPayoutsListResponse, _a1 error) *MockAccountingServiceClient_GetCurrentPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentPayoutsList_Call) RunAndReturn(run func(context.Context, *accounting.GetCurrentPayoutsListRequest, ...grpc.CallOption) (*accounting.GetCurrentPayoutsListResponse, error)) *MockAccountingServiceClient_GetCurrentPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentReferralsPayoutsList provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetCurrentReferralsPayoutsList(ctx context.Context, in *accounting.GetCurrentReferralsPayoutsListRequest, opts ...grpc.CallOption) (*accounting.GetCurrentReferralsPayoutsListResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentReferralsPayoutsList")
	}

	var r0 *accounting.GetCurrentReferralsPayoutsListResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentReferralsPayoutsListRequest, ...grpc.CallOption) (*accounting.GetCurrentReferralsPayoutsListResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetCurrentReferralsPayoutsListRequest, ...grpc.CallOption) *accounting.GetCurrentReferralsPayoutsListResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetCurrentReferralsPayoutsListResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetCurrentReferralsPayoutsListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentReferralsPayoutsList'
type MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentReferralsPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetCurrentReferralsPayoutsListRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetCurrentReferralsPayoutsList(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call {
	return &MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call{Call: _e.mock.On("GetCurrentReferralsPayoutsList",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call) Run(run func(ctx context.Context, in *accounting.GetCurrentReferralsPayoutsListRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetCurrentReferralsPayoutsListRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call) Return(_a0 *accounting.GetCurrentReferralsPayoutsListResponse, _a1 error) *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call) RunAndReturn(run func(context.Context, *accounting.GetCurrentReferralsPayoutsListRequest, ...grpc.CallOption) (*accounting.GetCurrentReferralsPayoutsListResponse, error)) *MockAccountingServiceClient_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetFreePayouts provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetFreePayouts(ctx context.Context, in *accounting.GetFreePayoutsRequest, opts ...grpc.CallOption) (*accounting.GetFreePayoutsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFreePayouts")
	}

	var r0 *accounting.GetFreePayoutsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetFreePayoutsRequest, ...grpc.CallOption) (*accounting.GetFreePayoutsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetFreePayoutsRequest, ...grpc.CallOption) *accounting.GetFreePayoutsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetFreePayoutsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetFreePayoutsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetFreePayouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFreePayouts'
type MockAccountingServiceClient_GetFreePayouts_Call struct {
	*mock.Call
}

// GetFreePayouts is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetFreePayoutsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetFreePayouts(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetFreePayouts_Call {
	return &MockAccountingServiceClient_GetFreePayouts_Call{Call: _e.mock.On("GetFreePayouts",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetFreePayouts_Call) Run(run func(ctx context.Context, in *accounting.GetFreePayoutsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetFreePayouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetFreePayoutsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetFreePayouts_Call) Return(_a0 *accounting.GetFreePayoutsResponse, _a1 error) *MockAccountingServiceClient_GetFreePayouts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetFreePayouts_Call) RunAndReturn(run func(context.Context, *accounting.GetFreePayoutsRequest, ...grpc.CallOption) (*accounting.GetFreePayoutsResponse, error)) *MockAccountingServiceClient_GetFreePayouts_Call {
	_c.Call.Return(run)
	return _c
}

// GetHistory provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetHistory(ctx context.Context, in *accounting.GetHistoryRequest, opts ...grpc.CallOption) (*accounting.GetHistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHistory")
	}

	var r0 *accounting.GetHistoryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetHistoryRequest, ...grpc.CallOption) (*accounting.GetHistoryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetHistoryRequest, ...grpc.CallOption) *accounting.GetHistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetHistoryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetHistoryRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHistory'
type MockAccountingServiceClient_GetHistory_Call struct {
	*mock.Call
}

// GetHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetHistoryRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetHistory(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetHistory_Call {
	return &MockAccountingServiceClient_GetHistory_Call{Call: _e.mock.On("GetHistory",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetHistory_Call) Run(run func(ctx context.Context, in *accounting.GetHistoryRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetHistoryRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetHistory_Call) Return(_a0 *accounting.GetHistoryResponse, _a1 error) *MockAccountingServiceClient_GetHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetHistory_Call) RunAndReturn(run func(context.Context, *accounting.GetHistoryRequest, ...grpc.CallOption) (*accounting.GetHistoryResponse, error)) *MockAccountingServiceClient_GetHistory_Call {
	_c.Call.Return(run)
	return _c
}

// GetIncomesHashrateByDate provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetIncomesHashrateByDate(ctx context.Context, in *accounting.GetIncomesHashrateRequest, opts ...grpc.CallOption) (*accounting.GetIncomesHashrateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIncomesHashrateByDate")
	}

	var r0 *accounting.GetIncomesHashrateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetIncomesHashrateRequest, ...grpc.CallOption) (*accounting.GetIncomesHashrateResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetIncomesHashrateRequest, ...grpc.CallOption) *accounting.GetIncomesHashrateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetIncomesHashrateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetIncomesHashrateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetIncomesHashrateByDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIncomesHashrateByDate'
type MockAccountingServiceClient_GetIncomesHashrateByDate_Call struct {
	*mock.Call
}

// GetIncomesHashrateByDate is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetIncomesHashrateRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetIncomesHashrateByDate(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetIncomesHashrateByDate_Call {
	return &MockAccountingServiceClient_GetIncomesHashrateByDate_Call{Call: _e.mock.On("GetIncomesHashrateByDate",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetIncomesHashrateByDate_Call) Run(run func(ctx context.Context, in *accounting.GetIncomesHashrateRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetIncomesHashrateByDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetIncomesHashrateRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetIncomesHashrateByDate_Call) Return(_a0 *accounting.GetIncomesHashrateResponse, _a1 error) *MockAccountingServiceClient_GetIncomesHashrateByDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetIncomesHashrateByDate_Call) RunAndReturn(run func(context.Context, *accounting.GetIncomesHashrateRequest, ...grpc.CallOption) (*accounting.GetIncomesHashrateResponse, error)) *MockAccountingServiceClient_GetIncomesHashrateByDate_Call {
	_c.Call.Return(run)
	return _c
}

// GetPaid provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetPaid(ctx context.Context, in *accounting.GetPaidRequest, opts ...grpc.CallOption) (*accounting.GetPaidResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPaid")
	}

	var r0 *accounting.GetPaidResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetPaidRequest, ...grpc.CallOption) (*accounting.GetPaidResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetPaidRequest, ...grpc.CallOption) *accounting.GetPaidResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetPaidResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetPaidRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetPaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPaid'
type MockAccountingServiceClient_GetPaid_Call struct {
	*mock.Call
}

// GetPaid is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetPaidRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetPaid(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetPaid_Call {
	return &MockAccountingServiceClient_GetPaid_Call{Call: _e.mock.On("GetPaid",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetPaid_Call) Run(run func(ctx context.Context, in *accounting.GetPaidRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetPaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetPaidRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetPaid_Call) Return(_a0 *accounting.GetPaidResponse, _a1 error) *MockAccountingServiceClient_GetPaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetPaid_Call) RunAndReturn(run func(context.Context, *accounting.GetPaidRequest, ...grpc.CallOption) (*accounting.GetPaidResponse, error)) *MockAccountingServiceClient_GetPaid_Call {
	_c.Call.Return(run)
	return _c
}

// GetPayoutsBlockStatus provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetPayoutsBlockStatus(ctx context.Context, in *accounting.GetPayoutsBlockStatusRequest, opts ...grpc.CallOption) (*accounting.GetPayoutsBlockStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPayoutsBlockStatus")
	}

	var r0 *accounting.GetPayoutsBlockStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetPayoutsBlockStatusRequest, ...grpc.CallOption) (*accounting.GetPayoutsBlockStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetPayoutsBlockStatusRequest, ...grpc.CallOption) *accounting.GetPayoutsBlockStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetPayoutsBlockStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetPayoutsBlockStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetPayoutsBlockStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPayoutsBlockStatus'
type MockAccountingServiceClient_GetPayoutsBlockStatus_Call struct {
	*mock.Call
}

// GetPayoutsBlockStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetPayoutsBlockStatusRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetPayoutsBlockStatus(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetPayoutsBlockStatus_Call {
	return &MockAccountingServiceClient_GetPayoutsBlockStatus_Call{Call: _e.mock.On("GetPayoutsBlockStatus",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetPayoutsBlockStatus_Call) Run(run func(ctx context.Context, in *accounting.GetPayoutsBlockStatusRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetPayoutsBlockStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetPayoutsBlockStatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetPayoutsBlockStatus_Call) Return(_a0 *accounting.GetPayoutsBlockStatusResponse, _a1 error) *MockAccountingServiceClient_GetPayoutsBlockStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetPayoutsBlockStatus_Call) RunAndReturn(run func(context.Context, *accounting.GetPayoutsBlockStatusRequest, ...grpc.CallOption) (*accounting.GetPayoutsBlockStatusResponse, error)) *MockAccountingServiceClient_GetPayoutsBlockStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceUserData provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetServiceUserData(ctx context.Context, in *accounting.GetServiceUserDataRequest, opts ...grpc.CallOption) (*accounting.GetServiceUserDataResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceUserData")
	}

	var r0 *accounting.GetServiceUserDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetServiceUserDataRequest, ...grpc.CallOption) (*accounting.GetServiceUserDataResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetServiceUserDataRequest, ...grpc.CallOption) *accounting.GetServiceUserDataResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetServiceUserDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetServiceUserDataRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetServiceUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceUserData'
type MockAccountingServiceClient_GetServiceUserData_Call struct {
	*mock.Call
}

// GetServiceUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetServiceUserDataRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetServiceUserData(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetServiceUserData_Call {
	return &MockAccountingServiceClient_GetServiceUserData_Call{Call: _e.mock.On("GetServiceUserData",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetServiceUserData_Call) Run(run func(ctx context.Context, in *accounting.GetServiceUserDataRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetServiceUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetServiceUserDataRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetServiceUserData_Call) Return(_a0 *accounting.GetServiceUserDataResponse, _a1 error) *MockAccountingServiceClient_GetServiceUserData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetServiceUserData_Call) RunAndReturn(run func(context.Context, *accounting.GetServiceUserDataRequest, ...grpc.CallOption) (*accounting.GetServiceUserDataResponse, error)) *MockAccountingServiceClient_GetServiceUserData_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByID provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetTransactionByID(ctx context.Context, in *accounting.GetTransactionByIDRequest, opts ...grpc.CallOption) (*accounting.GetTransactionByIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 *accounting.GetTransactionByIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionByIDRequest, ...grpc.CallOption) (*accounting.GetTransactionByIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionByIDRequest, ...grpc.CallOption) *accounting.GetTransactionByIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetTransactionByIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetTransactionByIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetTransactionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByID'
type MockAccountingServiceClient_GetTransactionByID_Call struct {
	*mock.Call
}

// GetTransactionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetTransactionByIDRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetTransactionByID(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetTransactionByID_Call {
	return &MockAccountingServiceClient_GetTransactionByID_Call{Call: _e.mock.On("GetTransactionByID",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetTransactionByID_Call) Run(run func(ctx context.Context, in *accounting.GetTransactionByIDRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetTransactionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetTransactionByIDRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionByID_Call) Return(_a0 *accounting.GetTransactionByIDResponse, _a1 error) *MockAccountingServiceClient_GetTransactionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionByID_Call) RunAndReturn(run func(context.Context, *accounting.GetTransactionByIDRequest, ...grpc.CallOption) (*accounting.GetTransactionByIDResponse, error)) *MockAccountingServiceClient_GetTransactionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionIDByAction provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetTransactionIDByAction(ctx context.Context, in *accounting.GetTransactionIDByActionRequest, opts ...grpc.CallOption) (*accounting.GetTransactionIDByActionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionIDByAction")
	}

	var r0 *accounting.GetTransactionIDByActionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionIDByActionRequest, ...grpc.CallOption) (*accounting.GetTransactionIDByActionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionIDByActionRequest, ...grpc.CallOption) *accounting.GetTransactionIDByActionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetTransactionIDByActionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetTransactionIDByActionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetTransactionIDByAction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionIDByAction'
type MockAccountingServiceClient_GetTransactionIDByAction_Call struct {
	*mock.Call
}

// GetTransactionIDByAction is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetTransactionIDByActionRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetTransactionIDByAction(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetTransactionIDByAction_Call {
	return &MockAccountingServiceClient_GetTransactionIDByAction_Call{Call: _e.mock.On("GetTransactionIDByAction",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetTransactionIDByAction_Call) Run(run func(ctx context.Context, in *accounting.GetTransactionIDByActionRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetTransactionIDByAction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetTransactionIDByActionRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionIDByAction_Call) Return(_a0 *accounting.GetTransactionIDByActionResponse, _a1 error) *MockAccountingServiceClient_GetTransactionIDByAction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionIDByAction_Call) RunAndReturn(run func(context.Context, *accounting.GetTransactionIDByActionRequest, ...grpc.CallOption) (*accounting.GetTransactionIDByActionResponse, error)) *MockAccountingServiceClient_GetTransactionIDByAction_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionOperationsIntegrity provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetTransactionOperationsIntegrity(ctx context.Context, in *accounting.GetTransactionOperationsIntegrityRequest, opts ...grpc.CallOption) (*accounting.GetTransactionOperationsIntegrityResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionOperationsIntegrity")
	}

	var r0 *accounting.GetTransactionOperationsIntegrityResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionOperationsIntegrityRequest, ...grpc.CallOption) (*accounting.GetTransactionOperationsIntegrityResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionOperationsIntegrityRequest, ...grpc.CallOption) *accounting.GetTransactionOperationsIntegrityResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetTransactionOperationsIntegrityResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetTransactionOperationsIntegrityRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionOperationsIntegrity'
type MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call struct {
	*mock.Call
}

// GetTransactionOperationsIntegrity is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetTransactionOperationsIntegrityRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetTransactionOperationsIntegrity(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call {
	return &MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call{Call: _e.mock.On("GetTransactionOperationsIntegrity",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call) Run(run func(ctx context.Context, in *accounting.GetTransactionOperationsIntegrityRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetTransactionOperationsIntegrityRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call) Return(_a0 *accounting.GetTransactionOperationsIntegrityResponse, _a1 error) *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call) RunAndReturn(run func(context.Context, *accounting.GetTransactionOperationsIntegrityRequest, ...grpc.CallOption) (*accounting.GetTransactionOperationsIntegrityResponse, error)) *MockAccountingServiceClient_GetTransactionOperationsIntegrity_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionsByActionID provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetTransactionsByActionID(ctx context.Context, in *accounting.GetTransactionsByActionIDRequest, opts ...grpc.CallOption) (*accounting.GetTransactionsByActionIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionsByActionID")
	}

	var r0 *accounting.GetTransactionsByActionIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionsByActionIDRequest, ...grpc.CallOption) (*accounting.GetTransactionsByActionIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetTransactionsByActionIDRequest, ...grpc.CallOption) *accounting.GetTransactionsByActionIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetTransactionsByActionIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetTransactionsByActionIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetTransactionsByActionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionsByActionID'
type MockAccountingServiceClient_GetTransactionsByActionID_Call struct {
	*mock.Call
}

// GetTransactionsByActionID is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetTransactionsByActionIDRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetTransactionsByActionID(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetTransactionsByActionID_Call {
	return &MockAccountingServiceClient_GetTransactionsByActionID_Call{Call: _e.mock.On("GetTransactionsByActionID",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetTransactionsByActionID_Call) Run(run func(ctx context.Context, in *accounting.GetTransactionsByActionIDRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetTransactionsByActionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetTransactionsByActionIDRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionsByActionID_Call) Return(_a0 *accounting.GetTransactionsByActionIDResponse, _a1 error) *MockAccountingServiceClient_GetTransactionsByActionID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetTransactionsByActionID_Call) RunAndReturn(run func(context.Context, *accounting.GetTransactionsByActionIDRequest, ...grpc.CallOption) (*accounting.GetTransactionsByActionIDResponse, error)) *MockAccountingServiceClient_GetTransactionsByActionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccount provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetUserAccount(ctx context.Context, in *accounting.GetUserAccountRequest, opts ...grpc.CallOption) (*accounting.GetUserAccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccount")
	}

	var r0 *accounting.GetUserAccountResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetUserAccountRequest, ...grpc.CallOption) (*accounting.GetUserAccountResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetUserAccountRequest, ...grpc.CallOption) *accounting.GetUserAccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetUserAccountResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetUserAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetUserAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccount'
type MockAccountingServiceClient_GetUserAccount_Call struct {
	*mock.Call
}

// GetUserAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetUserAccountRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetUserAccount(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetUserAccount_Call {
	return &MockAccountingServiceClient_GetUserAccount_Call{Call: _e.mock.On("GetUserAccount",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetUserAccount_Call) Run(run func(ctx context.Context, in *accounting.GetUserAccountRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetUserAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetUserAccountRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetUserAccount_Call) Return(_a0 *accounting.GetUserAccountResponse, _a1 error) *MockAccountingServiceClient_GetUserAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetUserAccount_Call) RunAndReturn(run func(context.Context, *accounting.GetUserAccountRequest, ...grpc.CallOption) (*accounting.GetUserAccountResponse, error)) *MockAccountingServiceClient_GetUserAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccounts provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) GetUserAccounts(ctx context.Context, in *accounting.GetUserAccountsRequest, opts ...grpc.CallOption) (*accounting.GetUserAccountsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccounts")
	}

	var r0 *accounting.GetUserAccountsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetUserAccountsRequest, ...grpc.CallOption) (*accounting.GetUserAccountsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.GetUserAccountsRequest, ...grpc.CallOption) *accounting.GetUserAccountsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.GetUserAccountsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.GetUserAccountsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_GetUserAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccounts'
type MockAccountingServiceClient_GetUserAccounts_Call struct {
	*mock.Call
}

// GetUserAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.GetUserAccountsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) GetUserAccounts(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_GetUserAccounts_Call {
	return &MockAccountingServiceClient_GetUserAccounts_Call{Call: _e.mock.On("GetUserAccounts",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_GetUserAccounts_Call) Run(run func(ctx context.Context, in *accounting.GetUserAccountsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_GetUserAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.GetUserAccountsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_GetUserAccounts_Call) Return(_a0 *accounting.GetUserAccountsResponse, _a1 error) *MockAccountingServiceClient_GetUserAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_GetUserAccounts_Call) RunAndReturn(run func(context.Context, *accounting.GetUserAccountsRequest, ...grpc.CallOption) (*accounting.GetUserAccountsResponse, error)) *MockAccountingServiceClient_GetUserAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactions provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) ListTransactions(ctx context.Context, in *accounting.ListTransactionsRequest, opts ...grpc.CallOption) (*accounting.ListTransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 *accounting.ListTransactionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ListTransactionsRequest, ...grpc.CallOption) (*accounting.ListTransactionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ListTransactionsRequest, ...grpc.CallOption) *accounting.ListTransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ListTransactionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.ListTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_ListTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactions'
type MockAccountingServiceClient_ListTransactions_Call struct {
	*mock.Call
}

// ListTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.ListTransactionsRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) ListTransactions(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_ListTransactions_Call {
	return &MockAccountingServiceClient_ListTransactions_Call{Call: _e.mock.On("ListTransactions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_ListTransactions_Call) Run(run func(ctx context.Context, in *accounting.ListTransactionsRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_ListTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.ListTransactionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_ListTransactions_Call) Return(_a0 *accounting.ListTransactionsResponse, _a1 error) *MockAccountingServiceClient_ListTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_ListTransactions_Call) RunAndReturn(run func(context.Context, *accounting.ListTransactionsRequest, ...grpc.CallOption) (*accounting.ListTransactionsResponse, error)) *MockAccountingServiceClient_ListTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// SetPayoutsBlockStatus provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) SetPayoutsBlockStatus(ctx context.Context, in *accounting.SetPayoutsBlockStatusRequest, opts ...grpc.CallOption) (*accounting.SetPayoutsBlockStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetPayoutsBlockStatus")
	}

	var r0 *accounting.SetPayoutsBlockStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.SetPayoutsBlockStatusRequest, ...grpc.CallOption) (*accounting.SetPayoutsBlockStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.SetPayoutsBlockStatusRequest, ...grpc.CallOption) *accounting.SetPayoutsBlockStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.SetPayoutsBlockStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.SetPayoutsBlockStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_SetPayoutsBlockStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPayoutsBlockStatus'
type MockAccountingServiceClient_SetPayoutsBlockStatus_Call struct {
	*mock.Call
}

// SetPayoutsBlockStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.SetPayoutsBlockStatusRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) SetPayoutsBlockStatus(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_SetPayoutsBlockStatus_Call {
	return &MockAccountingServiceClient_SetPayoutsBlockStatus_Call{Call: _e.mock.On("SetPayoutsBlockStatus",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_SetPayoutsBlockStatus_Call) Run(run func(ctx context.Context, in *accounting.SetPayoutsBlockStatusRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_SetPayoutsBlockStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.SetPayoutsBlockStatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_SetPayoutsBlockStatus_Call) Return(_a0 *accounting.SetPayoutsBlockStatusResponse, _a1 error) *MockAccountingServiceClient_SetPayoutsBlockStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_SetPayoutsBlockStatus_Call) RunAndReturn(run func(context.Context, *accounting.SetPayoutsBlockStatusRequest, ...grpc.CallOption) (*accounting.SetPayoutsBlockStatusResponse, error)) *MockAccountingServiceClient_SetPayoutsBlockStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ViewBalance provides a mock function with given fields: ctx, in, opts
func (_m *MockAccountingServiceClient) ViewBalance(ctx context.Context, in *accounting.ViewBalanceRequest, opts ...grpc.CallOption) (*accounting.ViewBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ViewBalance")
	}

	var r0 *accounting.ViewBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ViewBalanceRequest, ...grpc.CallOption) (*accounting.ViewBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *accounting.ViewBalanceRequest, ...grpc.CallOption) *accounting.ViewBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounting.ViewBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *accounting.ViewBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingServiceClient_ViewBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ViewBalance'
type MockAccountingServiceClient_ViewBalance_Call struct {
	*mock.Call
}

// ViewBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - in *accounting.ViewBalanceRequest
//   - opts ...grpc.CallOption
func (_e *MockAccountingServiceClient_Expecter) ViewBalance(ctx interface{}, in interface{}, opts ...interface{}) *MockAccountingServiceClient_ViewBalance_Call {
	return &MockAccountingServiceClient_ViewBalance_Call{Call: _e.mock.On("ViewBalance",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockAccountingServiceClient_ViewBalance_Call) Run(run func(ctx context.Context, in *accounting.ViewBalanceRequest, opts ...grpc.CallOption)) *MockAccountingServiceClient_ViewBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*accounting.ViewBalanceRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockAccountingServiceClient_ViewBalance_Call) Return(_a0 *accounting.ViewBalanceResponse, _a1 error) *MockAccountingServiceClient_ViewBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingServiceClient_ViewBalance_Call) RunAndReturn(run func(context.Context, *accounting.ViewBalanceRequest, ...grpc.CallOption) (*accounting.ViewBalanceResponse, error)) *MockAccountingServiceClient_ViewBalance_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountingServiceClient creates a new instance of MockAccountingServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountingServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountingServiceClient {
	mock := &MockAccountingServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

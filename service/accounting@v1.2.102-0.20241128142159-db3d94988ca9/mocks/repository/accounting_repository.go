// Code generated by mockery v2.43.2. DO NOT EDIT.

package repository

import (
	context "context"

	decimal "github.com/shopspring/decimal"
	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/service/accounting/model"

	time "time"
)

// MockAccountingRepository is an autogenerated mock type for the AccountingRepository type
type MockAccountingRepository struct {
	mock.Mock
}

type MockAccountingRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountingRepository) EXPECT() *MockAccountingRepository_Expecter {
	return &MockAccountingRepository_Expecter{mock: &_m.Mock}
}

// ChangeBalance provides a mock function with given fields: ctx, transactions
func (_m *MockAccountingRepository) ChangeBalance(ctx context.Context, transactions []*model.Transaction) error {
	ret := _m.Called(ctx, transactions)

	if len(ret) == 0 {
		panic("no return value specified for ChangeBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*model.Transaction) error); ok {
		r0 = rf(ctx, transactions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAccountingRepository_ChangeBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeBalance'
type MockAccountingRepository_ChangeBalance_Call struct {
	*mock.Call
}

// ChangeBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - transactions []*model.Transaction
func (_e *MockAccountingRepository_Expecter) ChangeBalance(ctx interface{}, transactions interface{}) *MockAccountingRepository_ChangeBalance_Call {
	return &MockAccountingRepository_ChangeBalance_Call{Call: _e.mock.On("ChangeBalance", ctx, transactions)}
}

func (_c *MockAccountingRepository_ChangeBalance_Call) Run(run func(ctx context.Context, transactions []*model.Transaction)) *MockAccountingRepository_ChangeBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*model.Transaction))
	})
	return _c
}

func (_c *MockAccountingRepository_ChangeBalance_Call) Return(_a0 error) *MockAccountingRepository_ChangeBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAccountingRepository_ChangeBalance_Call) RunAndReturn(run func(context.Context, []*model.Transaction) error) *MockAccountingRepository_ChangeBalance_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffMining provides a mock function with given fields: ctx, data
func (_m *MockAccountingRepository) FindBalancesDiffMining(ctx context.Context, data []model.UserBeforePayoutMining) (map[int64]decimal.Decimal, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffMining")
	}

	var r0 map[int64]decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []model.UserBeforePayoutMining) (map[int64]decimal.Decimal, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []model.UserBeforePayoutMining) map[int64]decimal.Decimal); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int64]decimal.Decimal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []model.UserBeforePayoutMining) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindBalancesDiffMining_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffMining'
type MockAccountingRepository_FindBalancesDiffMining_Call struct {
	*mock.Call
}

// FindBalancesDiffMining is a helper method to define mock.On call
//   - ctx context.Context
//   - data []model.UserBeforePayoutMining
func (_e *MockAccountingRepository_Expecter) FindBalancesDiffMining(ctx interface{}, data interface{}) *MockAccountingRepository_FindBalancesDiffMining_Call {
	return &MockAccountingRepository_FindBalancesDiffMining_Call{Call: _e.mock.On("FindBalancesDiffMining", ctx, data)}
}

func (_c *MockAccountingRepository_FindBalancesDiffMining_Call) Run(run func(ctx context.Context, data []model.UserBeforePayoutMining)) *MockAccountingRepository_FindBalancesDiffMining_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]model.UserBeforePayoutMining))
	})
	return _c
}

func (_c *MockAccountingRepository_FindBalancesDiffMining_Call) Return(_a0 map[int64]decimal.Decimal, _a1 error) *MockAccountingRepository_FindBalancesDiffMining_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindBalancesDiffMining_Call) RunAndReturn(run func(context.Context, []model.UserBeforePayoutMining) (map[int64]decimal.Decimal, error)) *MockAccountingRepository_FindBalancesDiffMining_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffWallet provides a mock function with given fields: ctx, data
func (_m *MockAccountingRepository) FindBalancesDiffWallet(ctx context.Context, data []model.UserBeforePayoutWallet) (map[int64][]model.UserWalletDiff, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffWallet")
	}

	var r0 map[int64][]model.UserWalletDiff
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []model.UserBeforePayoutWallet) (map[int64][]model.UserWalletDiff, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []model.UserBeforePayoutWallet) map[int64][]model.UserWalletDiff); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int64][]model.UserWalletDiff)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []model.UserBeforePayoutWallet) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindBalancesDiffWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffWallet'
type MockAccountingRepository_FindBalancesDiffWallet_Call struct {
	*mock.Call
}

// FindBalancesDiffWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - data []model.UserBeforePayoutWallet
func (_e *MockAccountingRepository_Expecter) FindBalancesDiffWallet(ctx interface{}, data interface{}) *MockAccountingRepository_FindBalancesDiffWallet_Call {
	return &MockAccountingRepository_FindBalancesDiffWallet_Call{Call: _e.mock.On("FindBalancesDiffWallet", ctx, data)}
}

func (_c *MockAccountingRepository_FindBalancesDiffWallet_Call) Run(run func(ctx context.Context, data []model.UserBeforePayoutWallet)) *MockAccountingRepository_FindBalancesDiffWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]model.UserBeforePayoutWallet))
	})
	return _c
}

func (_c *MockAccountingRepository_FindBalancesDiffWallet_Call) Return(_a0 map[int64][]model.UserWalletDiff, _a1 error) *MockAccountingRepository_FindBalancesDiffWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindBalancesDiffWallet_Call) RunAndReturn(run func(context.Context, []model.UserBeforePayoutWallet) (map[int64][]model.UserWalletDiff, error)) *MockAccountingRepository_FindBalancesDiffWallet_Call {
	_c.Call.Return(run)
	return _c
}

// FindBatchOperations provides a mock function with given fields: ctx, usersWithCoins
func (_m *MockAccountingRepository) FindBatchOperations(ctx context.Context, usersWithCoins map[int]int) (map[int64][]*model.OperationSelection, error) {
	ret := _m.Called(ctx, usersWithCoins)

	if len(ret) == 0 {
		panic("no return value specified for FindBatchOperations")
	}

	var r0 map[int64][]*model.OperationSelection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[int]int) (map[int64][]*model.OperationSelection, error)); ok {
		return rf(ctx, usersWithCoins)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[int]int) map[int64][]*model.OperationSelection); ok {
		r0 = rf(ctx, usersWithCoins)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int64][]*model.OperationSelection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[int]int) error); ok {
		r1 = rf(ctx, usersWithCoins)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindBatchOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBatchOperations'
type MockAccountingRepository_FindBatchOperations_Call struct {
	*mock.Call
}

// FindBatchOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - usersWithCoins map[int]int
func (_e *MockAccountingRepository_Expecter) FindBatchOperations(ctx interface{}, usersWithCoins interface{}) *MockAccountingRepository_FindBatchOperations_Call {
	return &MockAccountingRepository_FindBatchOperations_Call{Call: _e.mock.On("FindBatchOperations", ctx, usersWithCoins)}
}

func (_c *MockAccountingRepository_FindBatchOperations_Call) Run(run func(ctx context.Context, usersWithCoins map[int]int)) *MockAccountingRepository_FindBatchOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[int]int))
	})
	return _c
}

func (_c *MockAccountingRepository_FindBatchOperations_Call) Return(_a0 map[int64][]*model.OperationSelection, _a1 error) *MockAccountingRepository_FindBatchOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindBatchOperations_Call) RunAndReturn(run func(context.Context, map[int]int) (map[int64][]*model.OperationSelection, error)) *MockAccountingRepository_FindBatchOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindLastBlockTimeBalances provides a mock function with given fields: ctx, data
func (_m *MockAccountingRepository) FindLastBlockTimeBalances(ctx context.Context, data []int64) (map[int64]decimal.Decimal, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for FindLastBlockTimeBalances")
	}

	var r0 map[int64]decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int64) (map[int64]decimal.Decimal, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int64) map[int64]decimal.Decimal); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int64]decimal.Decimal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int64) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindLastBlockTimeBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindLastBlockTimeBalances'
type MockAccountingRepository_FindLastBlockTimeBalances_Call struct {
	*mock.Call
}

// FindLastBlockTimeBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - data []int64
func (_e *MockAccountingRepository_Expecter) FindLastBlockTimeBalances(ctx interface{}, data interface{}) *MockAccountingRepository_FindLastBlockTimeBalances_Call {
	return &MockAccountingRepository_FindLastBlockTimeBalances_Call{Call: _e.mock.On("FindLastBlockTimeBalances", ctx, data)}
}

func (_c *MockAccountingRepository_FindLastBlockTimeBalances_Call) Run(run func(ctx context.Context, data []int64)) *MockAccountingRepository_FindLastBlockTimeBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int64))
	})
	return _c
}

func (_c *MockAccountingRepository_FindLastBlockTimeBalances_Call) Return(_a0 map[int64]decimal.Decimal, _a1 error) *MockAccountingRepository_FindLastBlockTimeBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindLastBlockTimeBalances_Call) RunAndReturn(run func(context.Context, []int64) (map[int64]decimal.Decimal, error)) *MockAccountingRepository_FindLastBlockTimeBalances_Call {
	_c.Call.Return(run)
	return _c
}

// FindOperations provides a mock function with given fields: ctx, userID, coinID
func (_m *MockAccountingRepository) FindOperations(ctx context.Context, userID int64, coinID int64) ([]*model.OperationSelectionWithBlock, error) {
	ret := _m.Called(ctx, userID, coinID)

	if len(ret) == 0 {
		panic("no return value specified for FindOperations")
	}

	var r0 []*model.OperationSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) ([]*model.OperationSelectionWithBlock, error)); ok {
		return rf(ctx, userID, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) []*model.OperationSelectionWithBlock); ok {
		r0 = rf(ctx, userID, coinID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OperationSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, userID, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOperations'
type MockAccountingRepository_FindOperations_Call struct {
	*mock.Call
}

// FindOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - coinID int64
func (_e *MockAccountingRepository_Expecter) FindOperations(ctx interface{}, userID interface{}, coinID interface{}) *MockAccountingRepository_FindOperations_Call {
	return &MockAccountingRepository_FindOperations_Call{Call: _e.mock.On("FindOperations", ctx, userID, coinID)}
}

func (_c *MockAccountingRepository_FindOperations_Call) Run(run func(ctx context.Context, userID int64, coinID int64)) *MockAccountingRepository_FindOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockAccountingRepository_FindOperations_Call) Return(_a0 []*model.OperationSelectionWithBlock, _a1 error) *MockAccountingRepository_FindOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindOperations_Call) RunAndReturn(run func(context.Context, int64, int64) ([]*model.OperationSelectionWithBlock, error)) *MockAccountingRepository_FindOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactions provides a mock function with given fields: ctx, types, userID, userAccountID, coinIDs, from
func (_m *MockAccountingRepository) FindTransactions(ctx context.Context, types []int64, userID int, userAccountID int, coinIDs []int, from time.Time) ([]*model.Transaction, error) {
	ret := _m.Called(ctx, types, userID, userAccountID, coinIDs, from)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactions")
	}

	var r0 []*model.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int64, int, int, []int, time.Time) ([]*model.Transaction, error)); ok {
		return rf(ctx, types, userID, userAccountID, coinIDs, from)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int64, int, int, []int, time.Time) []*model.Transaction); ok {
		r0 = rf(ctx, types, userID, userAccountID, coinIDs, from)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int64, int, int, []int, time.Time) error); ok {
		r1 = rf(ctx, types, userID, userAccountID, coinIDs, from)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactions'
type MockAccountingRepository_FindTransactions_Call struct {
	*mock.Call
}

// FindTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - types []int64
//   - userID int
//   - userAccountID int
//   - coinIDs []int
//   - from time.Time
func (_e *MockAccountingRepository_Expecter) FindTransactions(ctx interface{}, types interface{}, userID interface{}, userAccountID interface{}, coinIDs interface{}, from interface{}) *MockAccountingRepository_FindTransactions_Call {
	return &MockAccountingRepository_FindTransactions_Call{Call: _e.mock.On("FindTransactions", ctx, types, userID, userAccountID, coinIDs, from)}
}

func (_c *MockAccountingRepository_FindTransactions_Call) Run(run func(ctx context.Context, types []int64, userID int, userAccountID int, coinIDs []int, from time.Time)) *MockAccountingRepository_FindTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int64), args[2].(int), args[3].(int), args[4].([]int), args[5].(time.Time))
	})
	return _c
}

func (_c *MockAccountingRepository_FindTransactions_Call) Return(_a0 []*model.Transaction, _a1 error) *MockAccountingRepository_FindTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindTransactions_Call) RunAndReturn(run func(context.Context, []int64, int, int, []int, time.Time) ([]*model.Transaction, error)) *MockAccountingRepository_FindTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactionsWithBlocks provides a mock function with given fields: ctx, blockedTill
func (_m *MockAccountingRepository) FindTransactionsWithBlocks(ctx context.Context, blockedTill time.Time) ([]*model.TransactionSelectionWithBlock, error) {
	ret := _m.Called(ctx, blockedTill)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactionsWithBlocks")
	}

	var r0 []*model.TransactionSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) ([]*model.TransactionSelectionWithBlock, error)); ok {
		return rf(ctx, blockedTill)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) []*model.TransactionSelectionWithBlock); ok {
		r0 = rf(ctx, blockedTill)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.TransactionSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = rf(ctx, blockedTill)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_FindTransactionsWithBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactionsWithBlocks'
type MockAccountingRepository_FindTransactionsWithBlocks_Call struct {
	*mock.Call
}

// FindTransactionsWithBlocks is a helper method to define mock.On call
//   - ctx context.Context
//   - blockedTill time.Time
func (_e *MockAccountingRepository_Expecter) FindTransactionsWithBlocks(ctx interface{}, blockedTill interface{}) *MockAccountingRepository_FindTransactionsWithBlocks_Call {
	return &MockAccountingRepository_FindTransactionsWithBlocks_Call{Call: _e.mock.On("FindTransactionsWithBlocks", ctx, blockedTill)}
}

func (_c *MockAccountingRepository_FindTransactionsWithBlocks_Call) Run(run func(ctx context.Context, blockedTill time.Time)) *MockAccountingRepository_FindTransactionsWithBlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *MockAccountingRepository_FindTransactionsWithBlocks_Call) Return(_a0 []*model.TransactionSelectionWithBlock, _a1 error) *MockAccountingRepository_FindTransactionsWithBlocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_FindTransactionsWithBlocks_Call) RunAndReturn(run func(context.Context, time.Time) ([]*model.TransactionSelectionWithBlock, error)) *MockAccountingRepository_FindTransactionsWithBlocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByID provides a mock function with given fields: ctx, id
func (_m *MockAccountingRepository) GetTransactionByID(ctx context.Context, id int) (*model.TransactionSelectionWithBlock, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 *model.TransactionSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.TransactionSelectionWithBlock, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.TransactionSelectionWithBlock); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TransactionSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_GetTransactionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByID'
type MockAccountingRepository_GetTransactionByID_Call struct {
	*mock.Call
}

// GetTransactionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockAccountingRepository_Expecter) GetTransactionByID(ctx interface{}, id interface{}) *MockAccountingRepository_GetTransactionByID_Call {
	return &MockAccountingRepository_GetTransactionByID_Call{Call: _e.mock.On("GetTransactionByID", ctx, id)}
}

func (_c *MockAccountingRepository_GetTransactionByID_Call) Run(run func(ctx context.Context, id int)) *MockAccountingRepository_GetTransactionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockAccountingRepository_GetTransactionByID_Call) Return(_a0 *model.TransactionSelectionWithBlock, _a1 error) *MockAccountingRepository_GetTransactionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_GetTransactionByID_Call) RunAndReturn(run func(context.Context, int) (*model.TransactionSelectionWithBlock, error)) *MockAccountingRepository_GetTransactionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionIDByAction provides a mock function with given fields: ctx, actionID, amount, Type
func (_m *MockAccountingRepository) GetTransactionIDByAction(ctx context.Context, actionID string, amount decimal.Decimal, Type model.TransactionType) (int, error) {
	ret := _m.Called(ctx, actionID, amount, Type)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionIDByAction")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, model.TransactionType) (int, error)); ok {
		return rf(ctx, actionID, amount, Type)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, model.TransactionType) int); ok {
		r0 = rf(ctx, actionID, amount, Type)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, decimal.Decimal, model.TransactionType) error); ok {
		r1 = rf(ctx, actionID, amount, Type)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_GetTransactionIDByAction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionIDByAction'
type MockAccountingRepository_GetTransactionIDByAction_Call struct {
	*mock.Call
}

// GetTransactionIDByAction is a helper method to define mock.On call
//   - ctx context.Context
//   - actionID string
//   - amount decimal.Decimal
//   - Type model.TransactionType
func (_e *MockAccountingRepository_Expecter) GetTransactionIDByAction(ctx interface{}, actionID interface{}, amount interface{}, Type interface{}) *MockAccountingRepository_GetTransactionIDByAction_Call {
	return &MockAccountingRepository_GetTransactionIDByAction_Call{Call: _e.mock.On("GetTransactionIDByAction", ctx, actionID, amount, Type)}
}

func (_c *MockAccountingRepository_GetTransactionIDByAction_Call) Run(run func(ctx context.Context, actionID string, amount decimal.Decimal, Type model.TransactionType)) *MockAccountingRepository_GetTransactionIDByAction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(decimal.Decimal), args[3].(model.TransactionType))
	})
	return _c
}

func (_c *MockAccountingRepository_GetTransactionIDByAction_Call) Return(_a0 int, _a1 error) *MockAccountingRepository_GetTransactionIDByAction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_GetTransactionIDByAction_Call) RunAndReturn(run func(context.Context, string, decimal.Decimal, model.TransactionType) (int, error)) *MockAccountingRepository_GetTransactionIDByAction_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionsByActionID provides a mock function with given fields: ctx, actionID
func (_m *MockAccountingRepository) GetTransactionsByActionID(ctx context.Context, actionID string) ([]*model.Transaction, error) {
	ret := _m.Called(ctx, actionID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionsByActionID")
	}

	var r0 []*model.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*model.Transaction, error)); ok {
		return rf(ctx, actionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.Transaction); ok {
		r0 = rf(ctx, actionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, actionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_GetTransactionsByActionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionsByActionID'
type MockAccountingRepository_GetTransactionsByActionID_Call struct {
	*mock.Call
}

// GetTransactionsByActionID is a helper method to define mock.On call
//   - ctx context.Context
//   - actionID string
func (_e *MockAccountingRepository_Expecter) GetTransactionsByActionID(ctx interface{}, actionID interface{}) *MockAccountingRepository_GetTransactionsByActionID_Call {
	return &MockAccountingRepository_GetTransactionsByActionID_Call{Call: _e.mock.On("GetTransactionsByActionID", ctx, actionID)}
}

func (_c *MockAccountingRepository_GetTransactionsByActionID_Call) Run(run func(ctx context.Context, actionID string)) *MockAccountingRepository_GetTransactionsByActionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockAccountingRepository_GetTransactionsByActionID_Call) Return(_a0 []*model.Transaction, _a1 error) *MockAccountingRepository_GetTransactionsByActionID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingRepository_GetTransactionsByActionID_Call) RunAndReturn(run func(context.Context, string) ([]*model.Transaction, error)) *MockAccountingRepository_GetTransactionsByActionID_Call {
	_c.Call.Return(run)
	return _c
}

// ViewBalance provides a mock function with given fields: ctx, userID, coinID, accountTypeID, totalBalance
func (_m *MockAccountingRepository) ViewBalance(ctx context.Context, userID int64, coinID string, accountTypeID int64, totalBalance bool) (string, error) {
	ret := _m.Called(ctx, userID, coinID, accountTypeID, totalBalance)

	if len(ret) == 0 {
		panic("no return value specified for ViewBalance")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64, bool) (string, error)); ok {
		return rf(ctx, userID, coinID, accountTypeID, totalBalance)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64, bool) string); ok {
		r0 = rf(ctx, userID, coinID, accountTypeID, totalBalance)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, int64, bool) error); ok {
		r1 = rf(ctx, userID, coinID, accountTypeID, totalBalance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingRepository_ViewBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ViewBalance'
type MockAccountingRepository_ViewBalance_Call struct {
	*mock.Call
}

// ViewBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - coinID string
//   - accountTypeID int64
//   - totalBalance bool
func (_e *MockAccountingRepository_Expecter) ViewBalance(ctx interface{}, userID interface{}, coinID interface{}, accountTypeID interface{}, totalBalance interface{}) *MockAccountingRepository_ViewBalance_Call {
	return &MockAccountingRepository_ViewBalance_Call{Call: _e.mock.On("ViewBalance", ctx, userID, coinID, accountTypeID, totalBalance)}
}

func (_c *MockAccountingRepository_ViewBalance_Call) Run(run func(ctx context.Context, userID int64, coinID string, accountTypeID int64, totalBalance bool)) *MockAccountingRepository_ViewBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(int64), args[4].(bool))
	})
	return _c
}

func (_c *MockAccountingRepository_ViewBalance_Call) Return(balance string, err error) *MockAccountingRepository_ViewBalance_Call {
	_c.Call.Return(balance, err)
	return _c
}

func (_c *MockAccountingRepository_ViewBalance_Call) RunAndReturn(run func(context.Context, int64, string, int64, bool) (string, error)) *MockAccountingRepository_ViewBalance_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountingRepository creates a new instance of MockAccountingRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountingRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountingRepository {
	mock := &MockAccountingRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.43.2. DO NOT EDIT.

package repository

import (
	context "context"

	enum "code.emcdtech.com/emcd/service/accounting/model/enum"
	decimal "github.com/shopspring/decimal"

	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/service/accounting/model"

	pgx "github.com/jackc/pgx/v5"

	time "time"

	uuid "github.com/google/uuid"
)

// MockBalance is an autogenerated mock type for the Balance type
type MockBalance struct {
	mock.Mock
}

type MockBalance_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBalance) EXPECT() *MockBalance_Expecter {
	return &MockBalance_Expecter{mock: &_m.Mock}
}

// Change provides a mock function with given fields: ctx, sqlTx, transaction
func (_m *MockBalance) Change(ctx context.Context, sqlTx pgx.Tx, transaction *model.Transaction) (int, error) {
	ret := _m.Called(ctx, sqlTx, transaction)

	if len(ret) == 0 {
		panic("no return value specified for Change")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) (int, error)); ok {
		return rf(ctx, sqlTx, transaction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) int); ok {
		r0 = rf(ctx, sqlTx, transaction)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, *model.Transaction) error); ok {
		r1 = rf(ctx, sqlTx, transaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_Change_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Change'
type MockBalance_Change_Call struct {
	*mock.Call
}

// Change is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - transaction *model.Transaction
func (_e *MockBalance_Expecter) Change(ctx interface{}, sqlTx interface{}, transaction interface{}) *MockBalance_Change_Call {
	return &MockBalance_Change_Call{Call: _e.mock.On("Change", ctx, sqlTx, transaction)}
}

func (_c *MockBalance_Change_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, transaction *model.Transaction)) *MockBalance_Change_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(*model.Transaction))
	})
	return _c
}

func (_c *MockBalance_Change_Call) Return(transactionID int, err error) *MockBalance_Change_Call {
	_c.Call.Return(transactionID, err)
	return _c
}

func (_c *MockBalance_Change_Call) RunAndReturn(run func(context.Context, pgx.Tx, *model.Transaction) (int, error)) *MockBalance_Change_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeMultiple provides a mock function with given fields: ctx, trs
func (_m *MockBalance) ChangeMultiple(ctx context.Context, trs []*model.Transaction) error {
	ret := _m.Called(ctx, trs)

	if len(ret) == 0 {
		panic("no return value specified for ChangeMultiple")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*model.Transaction) error); ok {
		r0 = rf(ctx, trs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBalance_ChangeMultiple_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeMultiple'
type MockBalance_ChangeMultiple_Call struct {
	*mock.Call
}

// ChangeMultiple is a helper method to define mock.On call
//   - ctx context.Context
//   - trs []*model.Transaction
func (_e *MockBalance_Expecter) ChangeMultiple(ctx interface{}, trs interface{}) *MockBalance_ChangeMultiple_Call {
	return &MockBalance_ChangeMultiple_Call{Call: _e.mock.On("ChangeMultiple", ctx, trs)}
}

func (_c *MockBalance_ChangeMultiple_Call) Run(run func(ctx context.Context, trs []*model.Transaction)) *MockBalance_ChangeMultiple_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*model.Transaction))
	})
	return _c
}

func (_c *MockBalance_ChangeMultiple_Call) Return(_a0 error) *MockBalance_ChangeMultiple_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBalance_ChangeMultiple_Call) RunAndReturn(run func(context.Context, []*model.Transaction) error) *MockBalance_ChangeMultiple_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeWithBlock provides a mock function with given fields: ctx, sqlTx, transaction
func (_m *MockBalance) ChangeWithBlock(ctx context.Context, sqlTx pgx.Tx, transaction *model.Transaction) (int, error) {
	ret := _m.Called(ctx, sqlTx, transaction)

	if len(ret) == 0 {
		panic("no return value specified for ChangeWithBlock")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) (int, error)); ok {
		return rf(ctx, sqlTx, transaction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) int); ok {
		r0 = rf(ctx, sqlTx, transaction)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, *model.Transaction) error); ok {
		r1 = rf(ctx, sqlTx, transaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_ChangeWithBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeWithBlock'
type MockBalance_ChangeWithBlock_Call struct {
	*mock.Call
}

// ChangeWithBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - transaction *model.Transaction
func (_e *MockBalance_Expecter) ChangeWithBlock(ctx interface{}, sqlTx interface{}, transaction interface{}) *MockBalance_ChangeWithBlock_Call {
	return &MockBalance_ChangeWithBlock_Call{Call: _e.mock.On("ChangeWithBlock", ctx, sqlTx, transaction)}
}

func (_c *MockBalance_ChangeWithBlock_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, transaction *model.Transaction)) *MockBalance_ChangeWithBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(*model.Transaction))
	})
	return _c
}

func (_c *MockBalance_ChangeWithBlock_Call) Return(transactionID int, err error) *MockBalance_ChangeWithBlock_Call {
	_c.Call.Return(transactionID, err)
	return _c
}

func (_c *MockBalance_ChangeWithBlock_Call) RunAndReturn(run func(context.Context, pgx.Tx, *model.Transaction) (int, error)) *MockBalance_ChangeWithBlock_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeWithUnblock provides a mock function with given fields: ctx, sqlTx, unblockTransaction
func (_m *MockBalance) ChangeWithUnblock(ctx context.Context, sqlTx pgx.Tx, unblockTransaction *model.Transaction) (int, error) {
	ret := _m.Called(ctx, sqlTx, unblockTransaction)

	if len(ret) == 0 {
		panic("no return value specified for ChangeWithUnblock")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) (int, error)); ok {
		return rf(ctx, sqlTx, unblockTransaction)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, *model.Transaction) int); ok {
		r0 = rf(ctx, sqlTx, unblockTransaction)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, *model.Transaction) error); ok {
		r1 = rf(ctx, sqlTx, unblockTransaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_ChangeWithUnblock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeWithUnblock'
type MockBalance_ChangeWithUnblock_Call struct {
	*mock.Call
}

// ChangeWithUnblock is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - unblockTransaction *model.Transaction
func (_e *MockBalance_Expecter) ChangeWithUnblock(ctx interface{}, sqlTx interface{}, unblockTransaction interface{}) *MockBalance_ChangeWithUnblock_Call {
	return &MockBalance_ChangeWithUnblock_Call{Call: _e.mock.On("ChangeWithUnblock", ctx, sqlTx, unblockTransaction)}
}

func (_c *MockBalance_ChangeWithUnblock_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, unblockTransaction *model.Transaction)) *MockBalance_ChangeWithUnblock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(*model.Transaction))
	})
	return _c
}

func (_c *MockBalance_ChangeWithUnblock_Call) Return(transactionID int, err error) *MockBalance_ChangeWithUnblock_Call {
	_c.Call.Return(transactionID, err)
	return _c
}

func (_c *MockBalance_ChangeWithUnblock_Call) RunAndReturn(run func(context.Context, pgx.Tx, *model.Transaction) (int, error)) *MockBalance_ChangeWithUnblock_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccountPool provides a mock function with given fields: ctx, accountID
func (_m *MockBalance) CreateAccountPool(ctx context.Context, accountID int) error {
	ret := _m.Called(ctx, accountID)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccountPool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, accountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBalance_CreateAccountPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccountPool'
type MockBalance_CreateAccountPool_Call struct {
	*mock.Call
}

// CreateAccountPool is a helper method to define mock.On call
//   - ctx context.Context
//   - accountID int
func (_e *MockBalance_Expecter) CreateAccountPool(ctx interface{}, accountID interface{}) *MockBalance_CreateAccountPool_Call {
	return &MockBalance_CreateAccountPool_Call{Call: _e.mock.On("CreateAccountPool", ctx, accountID)}
}

func (_c *MockBalance_CreateAccountPool_Call) Run(run func(ctx context.Context, accountID int)) *MockBalance_CreateAccountPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockBalance_CreateAccountPool_Call) Return(_a0 error) *MockBalance_CreateAccountPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBalance_CreateAccountPool_Call) RunAndReturn(run func(context.Context, int) error) *MockBalance_CreateAccountPool_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccountReferral provides a mock function with given fields: ctx, accountID, coinID
func (_m *MockBalance) CreateAccountReferral(ctx context.Context, accountID int, coinID int) error {
	ret := _m.Called(ctx, accountID, coinID)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccountReferral")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = rf(ctx, accountID, coinID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBalance_CreateAccountReferral_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccountReferral'
type MockBalance_CreateAccountReferral_Call struct {
	*mock.Call
}

// CreateAccountReferral is a helper method to define mock.On call
//   - ctx context.Context
//   - accountID int
//   - coinID int
func (_e *MockBalance_Expecter) CreateAccountReferral(ctx interface{}, accountID interface{}, coinID interface{}) *MockBalance_CreateAccountReferral_Call {
	return &MockBalance_CreateAccountReferral_Call{Call: _e.mock.On("CreateAccountReferral", ctx, accountID, coinID)}
}

func (_c *MockBalance_CreateAccountReferral_Call) Run(run func(ctx context.Context, accountID int, coinID int)) *MockBalance_CreateAccountReferral_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockBalance_CreateAccountReferral_Call) Return(_a0 error) *MockBalance_CreateAccountReferral_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBalance_CreateAccountReferral_Call) RunAndReturn(run func(context.Context, int, int) error) *MockBalance_CreateAccountReferral_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUsersAccount provides a mock function with given fields: ctx, userID, accountType, coinID, minpay
func (_m *MockBalance) CreateUsersAccount(ctx context.Context, userID int32, accountType enum.AccountTypeId, coinID int, minpay float64) (int, error) {
	ret := _m.Called(ctx, userID, accountType, coinID, minpay)

	if len(ret) == 0 {
		panic("no return value specified for CreateUsersAccount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, enum.AccountTypeId, int, float64) (int, error)); ok {
		return rf(ctx, userID, accountType, coinID, minpay)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, enum.AccountTypeId, int, float64) int); ok {
		r0 = rf(ctx, userID, accountType, coinID, minpay)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, enum.AccountTypeId, int, float64) error); ok {
		r1 = rf(ctx, userID, accountType, coinID, minpay)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_CreateUsersAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUsersAccount'
type MockBalance_CreateUsersAccount_Call struct {
	*mock.Call
}

// CreateUsersAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - accountType enum.AccountTypeId
//   - coinID int
//   - minpay float64
func (_e *MockBalance_Expecter) CreateUsersAccount(ctx interface{}, userID interface{}, accountType interface{}, coinID interface{}, minpay interface{}) *MockBalance_CreateUsersAccount_Call {
	return &MockBalance_CreateUsersAccount_Call{Call: _e.mock.On("CreateUsersAccount", ctx, userID, accountType, coinID, minpay)}
}

func (_c *MockBalance_CreateUsersAccount_Call) Run(run func(ctx context.Context, userID int32, accountType enum.AccountTypeId, coinID int, minpay float64)) *MockBalance_CreateUsersAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(enum.AccountTypeId), args[3].(int), args[4].(float64))
	})
	return _c
}

func (_c *MockBalance_CreateUsersAccount_Call) Return(_a0 int, _a1 error) *MockBalance_CreateUsersAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_CreateUsersAccount_Call) RunAndReturn(run func(context.Context, int32, enum.AccountTypeId, int, float64) (int, error)) *MockBalance_CreateUsersAccount_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffMining provides a mock function with given fields: ctx, users
func (_m *MockBalance) FindBalancesDiffMining(ctx context.Context, users []*model.UserBeforePayoutMining) (map[int]decimal.Decimal, error) {
	ret := _m.Called(ctx, users)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffMining")
	}

	var r0 map[int]decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*model.UserBeforePayoutMining) (map[int]decimal.Decimal, error)); ok {
		return rf(ctx, users)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*model.UserBeforePayoutMining) map[int]decimal.Decimal); ok {
		r0 = rf(ctx, users)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]decimal.Decimal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*model.UserBeforePayoutMining) error); ok {
		r1 = rf(ctx, users)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindBalancesDiffMining_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffMining'
type MockBalance_FindBalancesDiffMining_Call struct {
	*mock.Call
}

// FindBalancesDiffMining is a helper method to define mock.On call
//   - ctx context.Context
//   - users []*model.UserBeforePayoutMining
func (_e *MockBalance_Expecter) FindBalancesDiffMining(ctx interface{}, users interface{}) *MockBalance_FindBalancesDiffMining_Call {
	return &MockBalance_FindBalancesDiffMining_Call{Call: _e.mock.On("FindBalancesDiffMining", ctx, users)}
}

func (_c *MockBalance_FindBalancesDiffMining_Call) Run(run func(ctx context.Context, users []*model.UserBeforePayoutMining)) *MockBalance_FindBalancesDiffMining_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*model.UserBeforePayoutMining))
	})
	return _c
}

func (_c *MockBalance_FindBalancesDiffMining_Call) Return(_a0 map[int]decimal.Decimal, _a1 error) *MockBalance_FindBalancesDiffMining_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindBalancesDiffMining_Call) RunAndReturn(run func(context.Context, []*model.UserBeforePayoutMining) (map[int]decimal.Decimal, error)) *MockBalance_FindBalancesDiffMining_Call {
	_c.Call.Return(run)
	return _c
}

// FindBalancesDiffWallet provides a mock function with given fields: ctx, users
func (_m *MockBalance) FindBalancesDiffWallet(ctx context.Context, users []*model.UserBeforePayoutWallet) ([]model.UserWalletDiff, error) {
	ret := _m.Called(ctx, users)

	if len(ret) == 0 {
		panic("no return value specified for FindBalancesDiffWallet")
	}

	var r0 []model.UserWalletDiff
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*model.UserBeforePayoutWallet) ([]model.UserWalletDiff, error)); ok {
		return rf(ctx, users)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*model.UserBeforePayoutWallet) []model.UserWalletDiff); ok {
		r0 = rf(ctx, users)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.UserWalletDiff)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*model.UserBeforePayoutWallet) error); ok {
		r1 = rf(ctx, users)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindBalancesDiffWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBalancesDiffWallet'
type MockBalance_FindBalancesDiffWallet_Call struct {
	*mock.Call
}

// FindBalancesDiffWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - users []*model.UserBeforePayoutWallet
func (_e *MockBalance_Expecter) FindBalancesDiffWallet(ctx interface{}, users interface{}) *MockBalance_FindBalancesDiffWallet_Call {
	return &MockBalance_FindBalancesDiffWallet_Call{Call: _e.mock.On("FindBalancesDiffWallet", ctx, users)}
}

func (_c *MockBalance_FindBalancesDiffWallet_Call) Run(run func(ctx context.Context, users []*model.UserBeforePayoutWallet)) *MockBalance_FindBalancesDiffWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*model.UserBeforePayoutWallet))
	})
	return _c
}

func (_c *MockBalance_FindBalancesDiffWallet_Call) Return(_a0 []model.UserWalletDiff, _a1 error) *MockBalance_FindBalancesDiffWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindBalancesDiffWallet_Call) RunAndReturn(run func(context.Context, []*model.UserBeforePayoutWallet) ([]model.UserWalletDiff, error)) *MockBalance_FindBalancesDiffWallet_Call {
	_c.Call.Return(run)
	return _c
}

// FindBatchOperations provides a mock function with given fields: ctx, usersWithCoins
func (_m *MockBalance) FindBatchOperations(ctx context.Context, usersWithCoins map[int]int) (map[int][]*model.OperationSelection, error) {
	ret := _m.Called(ctx, usersWithCoins)

	if len(ret) == 0 {
		panic("no return value specified for FindBatchOperations")
	}

	var r0 map[int][]*model.OperationSelection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[int]int) (map[int][]*model.OperationSelection, error)); ok {
		return rf(ctx, usersWithCoins)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[int]int) map[int][]*model.OperationSelection); ok {
		r0 = rf(ctx, usersWithCoins)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int][]*model.OperationSelection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[int]int) error); ok {
		r1 = rf(ctx, usersWithCoins)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindBatchOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBatchOperations'
type MockBalance_FindBatchOperations_Call struct {
	*mock.Call
}

// FindBatchOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - usersWithCoins map[int]int
func (_e *MockBalance_Expecter) FindBatchOperations(ctx interface{}, usersWithCoins interface{}) *MockBalance_FindBatchOperations_Call {
	return &MockBalance_FindBatchOperations_Call{Call: _e.mock.On("FindBatchOperations", ctx, usersWithCoins)}
}

func (_c *MockBalance_FindBatchOperations_Call) Run(run func(ctx context.Context, usersWithCoins map[int]int)) *MockBalance_FindBatchOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(map[int]int))
	})
	return _c
}

func (_c *MockBalance_FindBatchOperations_Call) Return(_a0 map[int][]*model.OperationSelection, _a1 error) *MockBalance_FindBatchOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindBatchOperations_Call) RunAndReturn(run func(context.Context, map[int]int) (map[int][]*model.OperationSelection, error)) *MockBalance_FindBatchOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindLastBlockTimeBalances provides a mock function with given fields: ctx, userAccountIDs
func (_m *MockBalance) FindLastBlockTimeBalances(ctx context.Context, userAccountIDs []int64) (map[int]decimal.Decimal, error) {
	ret := _m.Called(ctx, userAccountIDs)

	if len(ret) == 0 {
		panic("no return value specified for FindLastBlockTimeBalances")
	}

	var r0 map[int]decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int64) (map[int]decimal.Decimal, error)); ok {
		return rf(ctx, userAccountIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int64) map[int]decimal.Decimal); ok {
		r0 = rf(ctx, userAccountIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]decimal.Decimal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int64) error); ok {
		r1 = rf(ctx, userAccountIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindLastBlockTimeBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindLastBlockTimeBalances'
type MockBalance_FindLastBlockTimeBalances_Call struct {
	*mock.Call
}

// FindLastBlockTimeBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - userAccountIDs []int64
func (_e *MockBalance_Expecter) FindLastBlockTimeBalances(ctx interface{}, userAccountIDs interface{}) *MockBalance_FindLastBlockTimeBalances_Call {
	return &MockBalance_FindLastBlockTimeBalances_Call{Call: _e.mock.On("FindLastBlockTimeBalances", ctx, userAccountIDs)}
}

func (_c *MockBalance_FindLastBlockTimeBalances_Call) Run(run func(ctx context.Context, userAccountIDs []int64)) *MockBalance_FindLastBlockTimeBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int64))
	})
	return _c
}

func (_c *MockBalance_FindLastBlockTimeBalances_Call) Return(_a0 map[int]decimal.Decimal, _a1 error) *MockBalance_FindLastBlockTimeBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindLastBlockTimeBalances_Call) RunAndReturn(run func(context.Context, []int64) (map[int]decimal.Decimal, error)) *MockBalance_FindLastBlockTimeBalances_Call {
	_c.Call.Return(run)
	return _c
}

// FindOperations provides a mock function with given fields: ctx, userID, coinID
func (_m *MockBalance) FindOperations(ctx context.Context, userID int, coinID int) ([]*model.OperationSelectionWithBlock, error) {
	ret := _m.Called(ctx, userID, coinID)

	if len(ret) == 0 {
		panic("no return value specified for FindOperations")
	}

	var r0 []*model.OperationSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*model.OperationSelectionWithBlock, error)); ok {
		return rf(ctx, userID, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*model.OperationSelectionWithBlock); ok {
		r0 = rf(ctx, userID, coinID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OperationSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, userID, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOperations'
type MockBalance_FindOperations_Call struct {
	*mock.Call
}

// FindOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - coinID int
func (_e *MockBalance_Expecter) FindOperations(ctx interface{}, userID interface{}, coinID interface{}) *MockBalance_FindOperations_Call {
	return &MockBalance_FindOperations_Call{Call: _e.mock.On("FindOperations", ctx, userID, coinID)}
}

func (_c *MockBalance_FindOperations_Call) Run(run func(ctx context.Context, userID int, coinID int)) *MockBalance_FindOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockBalance_FindOperations_Call) Return(_a0 []*model.OperationSelectionWithBlock, _a1 error) *MockBalance_FindOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindOperations_Call) RunAndReturn(run func(context.Context, int, int) ([]*model.OperationSelectionWithBlock, error)) *MockBalance_FindOperations_Call {
	_c.Call.Return(run)
	return _c
}

// FindOperationsAndTransactions provides a mock function with given fields: ctx, queryParams
func (_m *MockBalance) FindOperationsAndTransactions(ctx context.Context, queryParams *model.OperationWithTransactionQuery) ([]*model.OperationWithTransaction, int64, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for FindOperationsAndTransactions")
	}

	var r0 []*model.OperationWithTransaction
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.OperationWithTransactionQuery) ([]*model.OperationWithTransaction, int64, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.OperationWithTransactionQuery) []*model.OperationWithTransaction); ok {
		r0 = rf(ctx, queryParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OperationWithTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.OperationWithTransactionQuery) int64); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.OperationWithTransactionQuery) error); ok {
		r2 = rf(ctx, queryParams)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockBalance_FindOperationsAndTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOperationsAndTransactions'
type MockBalance_FindOperationsAndTransactions_Call struct {
	*mock.Call
}

// FindOperationsAndTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams *model.OperationWithTransactionQuery
func (_e *MockBalance_Expecter) FindOperationsAndTransactions(ctx interface{}, queryParams interface{}) *MockBalance_FindOperationsAndTransactions_Call {
	return &MockBalance_FindOperationsAndTransactions_Call{Call: _e.mock.On("FindOperationsAndTransactions", ctx, queryParams)}
}

func (_c *MockBalance_FindOperationsAndTransactions_Call) Run(run func(ctx context.Context, queryParams *model.OperationWithTransactionQuery)) *MockBalance_FindOperationsAndTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.OperationWithTransactionQuery))
	})
	return _c
}

func (_c *MockBalance_FindOperationsAndTransactions_Call) Return(_a0 []*model.OperationWithTransaction, _a1 int64, _a2 error) *MockBalance_FindOperationsAndTransactions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockBalance_FindOperationsAndTransactions_Call) RunAndReturn(run func(context.Context, *model.OperationWithTransactionQuery) ([]*model.OperationWithTransaction, int64, error)) *MockBalance_FindOperationsAndTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactions provides a mock function with given fields: ctx, types, userID, accountTypeID, coinIDs, from
func (_m *MockBalance) FindTransactions(ctx context.Context, types []int, userID int, accountTypeID int, coinIDs []int, from time.Time) ([]*model.Transaction, error) {
	ret := _m.Called(ctx, types, userID, accountTypeID, coinIDs, from)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactions")
	}

	var r0 []*model.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int, int, int, []int, time.Time) ([]*model.Transaction, error)); ok {
		return rf(ctx, types, userID, accountTypeID, coinIDs, from)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int, int, int, []int, time.Time) []*model.Transaction); ok {
		r0 = rf(ctx, types, userID, accountTypeID, coinIDs, from)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int, int, int, []int, time.Time) error); ok {
		r1 = rf(ctx, types, userID, accountTypeID, coinIDs, from)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactions'
type MockBalance_FindTransactions_Call struct {
	*mock.Call
}

// FindTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - types []int
//   - userID int
//   - accountTypeID int
//   - coinIDs []int
//   - from time.Time
func (_e *MockBalance_Expecter) FindTransactions(ctx interface{}, types interface{}, userID interface{}, accountTypeID interface{}, coinIDs interface{}, from interface{}) *MockBalance_FindTransactions_Call {
	return &MockBalance_FindTransactions_Call{Call: _e.mock.On("FindTransactions", ctx, types, userID, accountTypeID, coinIDs, from)}
}

func (_c *MockBalance_FindTransactions_Call) Run(run func(ctx context.Context, types []int, userID int, accountTypeID int, coinIDs []int, from time.Time)) *MockBalance_FindTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int), args[2].(int), args[3].(int), args[4].([]int), args[5].(time.Time))
	})
	return _c
}

func (_c *MockBalance_FindTransactions_Call) Return(_a0 []*model.Transaction, _a1 error) *MockBalance_FindTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindTransactions_Call) RunAndReturn(run func(context.Context, []int, int, int, []int, time.Time) ([]*model.Transaction, error)) *MockBalance_FindTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactionsByCollectorFilter provides a mock function with given fields: ctx, filter
func (_m *MockBalance) FindTransactionsByCollectorFilter(ctx context.Context, filter *model.TransactionCollectorFilter) (*uint64, []*model.Transaction, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactionsByCollectorFilter")
	}

	var r0 *uint64
	var r1 []*model.Transaction
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.TransactionCollectorFilter) (*uint64, []*model.Transaction, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.TransactionCollectorFilter) *uint64); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.TransactionCollectorFilter) []*model.Transaction); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.TransactionCollectorFilter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockBalance_FindTransactionsByCollectorFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactionsByCollectorFilter'
type MockBalance_FindTransactionsByCollectorFilter_Call struct {
	*mock.Call
}

// FindTransactionsByCollectorFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.TransactionCollectorFilter
func (_e *MockBalance_Expecter) FindTransactionsByCollectorFilter(ctx interface{}, filter interface{}) *MockBalance_FindTransactionsByCollectorFilter_Call {
	return &MockBalance_FindTransactionsByCollectorFilter_Call{Call: _e.mock.On("FindTransactionsByCollectorFilter", ctx, filter)}
}

func (_c *MockBalance_FindTransactionsByCollectorFilter_Call) Run(run func(ctx context.Context, filter *model.TransactionCollectorFilter)) *MockBalance_FindTransactionsByCollectorFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.TransactionCollectorFilter))
	})
	return _c
}

func (_c *MockBalance_FindTransactionsByCollectorFilter_Call) Return(_a0 *uint64, _a1 []*model.Transaction, _a2 error) *MockBalance_FindTransactionsByCollectorFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockBalance_FindTransactionsByCollectorFilter_Call) RunAndReturn(run func(context.Context, *model.TransactionCollectorFilter) (*uint64, []*model.Transaction, error)) *MockBalance_FindTransactionsByCollectorFilter_Call {
	_c.Call.Return(run)
	return _c
}

// FindTransactionsWithBlocks provides a mock function with given fields: ctx, blockedTill
func (_m *MockBalance) FindTransactionsWithBlocks(ctx context.Context, blockedTill time.Time) ([]*model.TransactionSelectionWithBlock, error) {
	ret := _m.Called(ctx, blockedTill)

	if len(ret) == 0 {
		panic("no return value specified for FindTransactionsWithBlocks")
	}

	var r0 []*model.TransactionSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) ([]*model.TransactionSelectionWithBlock, error)); ok {
		return rf(ctx, blockedTill)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) []*model.TransactionSelectionWithBlock); ok {
		r0 = rf(ctx, blockedTill)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.TransactionSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = rf(ctx, blockedTill)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_FindTransactionsWithBlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTransactionsWithBlocks'
type MockBalance_FindTransactionsWithBlocks_Call struct {
	*mock.Call
}

// FindTransactionsWithBlocks is a helper method to define mock.On call
//   - ctx context.Context
//   - blockedTill time.Time
func (_e *MockBalance_Expecter) FindTransactionsWithBlocks(ctx interface{}, blockedTill interface{}) *MockBalance_FindTransactionsWithBlocks_Call {
	return &MockBalance_FindTransactionsWithBlocks_Call{Call: _e.mock.On("FindTransactionsWithBlocks", ctx, blockedTill)}
}

func (_c *MockBalance_FindTransactionsWithBlocks_Call) Run(run func(ctx context.Context, blockedTill time.Time)) *MockBalance_FindTransactionsWithBlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *MockBalance_FindTransactionsWithBlocks_Call) Return(_a0 []*model.TransactionSelectionWithBlock, _a1 error) *MockBalance_FindTransactionsWithBlocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_FindTransactionsWithBlocks_Call) RunAndReturn(run func(context.Context, time.Time) ([]*model.TransactionSelectionWithBlock, error)) *MockBalance_FindTransactionsWithBlocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountTypeIDByID provides a mock function with given fields: ctx, sqlTx, id
func (_m *MockBalance) GetAccountTypeIDByID(ctx context.Context, sqlTx pgx.Tx, id int) (enum.AccountTypeId, error) {
	ret := _m.Called(ctx, sqlTx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountTypeIDByID")
	}

	var r0 enum.AccountTypeId
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int) (enum.AccountTypeId, error)); ok {
		return rf(ctx, sqlTx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int) enum.AccountTypeId); ok {
		r0 = rf(ctx, sqlTx, id)
	} else {
		r0 = ret.Get(0).(enum.AccountTypeId)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, int) error); ok {
		r1 = rf(ctx, sqlTx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetAccountTypeIDByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountTypeIDByID'
type MockBalance_GetAccountTypeIDByID_Call struct {
	*mock.Call
}

// GetAccountTypeIDByID is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - id int
func (_e *MockBalance_Expecter) GetAccountTypeIDByID(ctx interface{}, sqlTx interface{}, id interface{}) *MockBalance_GetAccountTypeIDByID_Call {
	return &MockBalance_GetAccountTypeIDByID_Call{Call: _e.mock.On("GetAccountTypeIDByID", ctx, sqlTx, id)}
}

func (_c *MockBalance_GetAccountTypeIDByID_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, id int)) *MockBalance_GetAccountTypeIDByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(int))
	})
	return _c
}

func (_c *MockBalance_GetAccountTypeIDByID_Call) Return(_a0 enum.AccountTypeId, _a1 error) *MockBalance_GetAccountTypeIDByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetAccountTypeIDByID_Call) RunAndReturn(run func(context.Context, pgx.Tx, int) (enum.AccountTypeId, error)) *MockBalance_GetAccountTypeIDByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalanceBeforeTransaction provides a mock function with given fields: ctx, accountID, transactionID
func (_m *MockBalance) GetBalanceBeforeTransaction(ctx context.Context, accountID int64, transactionID int64) (decimal.Decimal, error) {
	ret := _m.Called(ctx, accountID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for GetBalanceBeforeTransaction")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) (decimal.Decimal, error)); ok {
		return rf(ctx, accountID, transactionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) decimal.Decimal); ok {
		r0 = rf(ctx, accountID, transactionID)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, accountID, transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBalanceBeforeTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalanceBeforeTransaction'
type MockBalance_GetBalanceBeforeTransaction_Call struct {
	*mock.Call
}

// GetBalanceBeforeTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - accountID int64
//   - transactionID int64
func (_e *MockBalance_Expecter) GetBalanceBeforeTransaction(ctx interface{}, accountID interface{}, transactionID interface{}) *MockBalance_GetBalanceBeforeTransaction_Call {
	return &MockBalance_GetBalanceBeforeTransaction_Call{Call: _e.mock.On("GetBalanceBeforeTransaction", ctx, accountID, transactionID)}
}

func (_c *MockBalance_GetBalanceBeforeTransaction_Call) Run(run func(ctx context.Context, accountID int64, transactionID int64)) *MockBalance_GetBalanceBeforeTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockBalance_GetBalanceBeforeTransaction_Call) Return(_a0 decimal.Decimal, _a1 error) *MockBalance_GetBalanceBeforeTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBalanceBeforeTransaction_Call) RunAndReturn(run func(context.Context, int64, int64) (decimal.Decimal, error)) *MockBalance_GetBalanceBeforeTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalanceByCoin provides a mock function with given fields: ctx, userID, coinID
func (_m *MockBalance) GetBalanceByCoin(ctx context.Context, userID int32, coinID int) (*model.Balance, error) {
	ret := _m.Called(ctx, userID, coinID)

	if len(ret) == 0 {
		panic("no return value specified for GetBalanceByCoin")
	}

	var r0 *model.Balance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int) (*model.Balance, error)); ok {
		return rf(ctx, userID, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int) *model.Balance); ok {
		r0 = rf(ctx, userID, coinID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Balance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int) error); ok {
		r1 = rf(ctx, userID, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBalanceByCoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalanceByCoin'
type MockBalance_GetBalanceByCoin_Call struct {
	*mock.Call
}

// GetBalanceByCoin is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - coinID int
func (_e *MockBalance_Expecter) GetBalanceByCoin(ctx interface{}, userID interface{}, coinID interface{}) *MockBalance_GetBalanceByCoin_Call {
	return &MockBalance_GetBalanceByCoin_Call{Call: _e.mock.On("GetBalanceByCoin", ctx, userID, coinID)}
}

func (_c *MockBalance_GetBalanceByCoin_Call) Run(run func(ctx context.Context, userID int32, coinID int)) *MockBalance_GetBalanceByCoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int))
	})
	return _c
}

func (_c *MockBalance_GetBalanceByCoin_Call) Return(_a0 *model.Balance, _a1 error) *MockBalance_GetBalanceByCoin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBalanceByCoin_Call) RunAndReturn(run func(context.Context, int32, int) (*model.Balance, error)) *MockBalance_GetBalanceByCoin_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalances provides a mock function with given fields: ctx, userID, walletCoinsIDs, walletCoinsStrIDs
func (_m *MockBalance) GetBalances(ctx context.Context, userID int32, walletCoinsIDs []int, walletCoinsStrIDs map[int]string) ([]*model.Balance, error) {
	ret := _m.Called(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetBalances")
	}

	var r0 []*model.Balance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, []int, map[int]string) ([]*model.Balance, error)); ok {
		return rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, []int, map[int]string) []*model.Balance); ok {
		r0 = rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Balance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, []int, map[int]string) error); ok {
		r1 = rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalances'
type MockBalance_GetBalances_Call struct {
	*mock.Call
}

// GetBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - walletCoinsIDs []int
//   - walletCoinsStrIDs map[int]string
func (_e *MockBalance_Expecter) GetBalances(ctx interface{}, userID interface{}, walletCoinsIDs interface{}, walletCoinsStrIDs interface{}) *MockBalance_GetBalances_Call {
	return &MockBalance_GetBalances_Call{Call: _e.mock.On("GetBalances", ctx, userID, walletCoinsIDs, walletCoinsStrIDs)}
}

func (_c *MockBalance_GetBalances_Call) Run(run func(ctx context.Context, userID int32, walletCoinsIDs []int, walletCoinsStrIDs map[int]string)) *MockBalance_GetBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].([]int), args[3].(map[int]string))
	})
	return _c
}

func (_c *MockBalance_GetBalances_Call) Return(_a0 []*model.Balance, _a1 error) *MockBalance_GetBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBalances_Call) RunAndReturn(run func(context.Context, int32, []int, map[int]string) ([]*model.Balance, error)) *MockBalance_GetBalances_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockAccountIDBySenderAccountID provides a mock function with given fields: ctx, sqlTx, id
func (_m *MockBalance) GetBlockAccountIDBySenderAccountID(ctx context.Context, sqlTx pgx.Tx, id int) (int32, error) {
	ret := _m.Called(ctx, sqlTx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAccountIDBySenderAccountID")
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int) (int32, error)); ok {
		return rf(ctx, sqlTx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int) int32); ok {
		r0 = rf(ctx, sqlTx, id)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, int) error); ok {
		r1 = rf(ctx, sqlTx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBlockAccountIDBySenderAccountID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockAccountIDBySenderAccountID'
type MockBalance_GetBlockAccountIDBySenderAccountID_Call struct {
	*mock.Call
}

// GetBlockAccountIDBySenderAccountID is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - id int
func (_e *MockBalance_Expecter) GetBlockAccountIDBySenderAccountID(ctx interface{}, sqlTx interface{}, id interface{}) *MockBalance_GetBlockAccountIDBySenderAccountID_Call {
	return &MockBalance_GetBlockAccountIDBySenderAccountID_Call{Call: _e.mock.On("GetBlockAccountIDBySenderAccountID", ctx, sqlTx, id)}
}

func (_c *MockBalance_GetBlockAccountIDBySenderAccountID_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, id int)) *MockBalance_GetBlockAccountIDBySenderAccountID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(int))
	})
	return _c
}

func (_c *MockBalance_GetBlockAccountIDBySenderAccountID_Call) Return(_a0 int32, _a1 error) *MockBalance_GetBlockAccountIDBySenderAccountID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBlockAccountIDBySenderAccountID_Call) RunAndReturn(run func(context.Context, pgx.Tx, int) (int32, error)) *MockBalance_GetBlockAccountIDBySenderAccountID_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockAccountIDFor31Type provides a mock function with given fields: ctx, sqlTx, coinID, username
func (_m *MockBalance) GetBlockAccountIDFor31Type(ctx context.Context, sqlTx pgx.Tx, coinID int, username string) (int32, error) {
	ret := _m.Called(ctx, sqlTx, coinID, username)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAccountIDFor31Type")
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int, string) (int32, error)); ok {
		return rf(ctx, sqlTx, coinID, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int, string) int32); ok {
		r0 = rf(ctx, sqlTx, coinID, username)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, int, string) error); ok {
		r1 = rf(ctx, sqlTx, coinID, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBlockAccountIDFor31Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockAccountIDFor31Type'
type MockBalance_GetBlockAccountIDFor31Type_Call struct {
	*mock.Call
}

// GetBlockAccountIDFor31Type is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - coinID int
//   - username string
func (_e *MockBalance_Expecter) GetBlockAccountIDFor31Type(ctx interface{}, sqlTx interface{}, coinID interface{}, username interface{}) *MockBalance_GetBlockAccountIDFor31Type_Call {
	return &MockBalance_GetBlockAccountIDFor31Type_Call{Call: _e.mock.On("GetBlockAccountIDFor31Type", ctx, sqlTx, coinID, username)}
}

func (_c *MockBalance_GetBlockAccountIDFor31Type_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, coinID int, username string)) *MockBalance_GetBlockAccountIDFor31Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockBalance_GetBlockAccountIDFor31Type_Call) Return(_a0 int32, _a1 error) *MockBalance_GetBlockAccountIDFor31Type_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBlockAccountIDFor31Type_Call) RunAndReturn(run func(context.Context, pgx.Tx, int, string) (int32, error)) *MockBalance_GetBlockAccountIDFor31Type_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockAccountIDFor57Type provides a mock function with given fields: ctx, sqlTx, coinID, username
func (_m *MockBalance) GetBlockAccountIDFor57Type(ctx context.Context, sqlTx pgx.Tx, coinID int, username string) (int32, error) {
	ret := _m.Called(ctx, sqlTx, coinID, username)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockAccountIDFor57Type")
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int, string) (int32, error)); ok {
		return rf(ctx, sqlTx, coinID, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, int, string) int32); ok {
		r0 = rf(ctx, sqlTx, coinID, username)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, int, string) error); ok {
		r1 = rf(ctx, sqlTx, coinID, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetBlockAccountIDFor57Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockAccountIDFor57Type'
type MockBalance_GetBlockAccountIDFor57Type_Call struct {
	*mock.Call
}

// GetBlockAccountIDFor57Type is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - coinID int
//   - username string
func (_e *MockBalance_Expecter) GetBlockAccountIDFor57Type(ctx interface{}, sqlTx interface{}, coinID interface{}, username interface{}) *MockBalance_GetBlockAccountIDFor57Type_Call {
	return &MockBalance_GetBlockAccountIDFor57Type_Call{Call: _e.mock.On("GetBlockAccountIDFor57Type", ctx, sqlTx, coinID, username)}
}

func (_c *MockBalance_GetBlockAccountIDFor57Type_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, coinID int, username string)) *MockBalance_GetBlockAccountIDFor57Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgx.Tx), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockBalance_GetBlockAccountIDFor57Type_Call) Return(_a0 int32, _a1 error) *MockBalance_GetBlockAccountIDFor57Type_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetBlockAccountIDFor57Type_Call) RunAndReturn(run func(context.Context, pgx.Tx, int, string) (int32, error)) *MockBalance_GetBlockAccountIDFor57Type_Call {
	_c.Call.Return(run)
	return _c
}

// GetCoinsSummary provides a mock function with given fields: ctx, userID, walletCoinsIDs, walletCoinsStrIDs
func (_m *MockBalance) GetCoinsSummary(ctx context.Context, userID int32, walletCoinsIDs []int, walletCoinsStrIDs map[int]string) ([]*model.CoinSummary, error) {
	ret := _m.Called(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetCoinsSummary")
	}

	var r0 []*model.CoinSummary
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, []int, map[int]string) ([]*model.CoinSummary, error)); ok {
		return rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, []int, map[int]string) []*model.CoinSummary); ok {
		r0 = rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.CoinSummary)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, []int, map[int]string) error); ok {
		r1 = rf(ctx, userID, walletCoinsIDs, walletCoinsStrIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetCoinsSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoinsSummary'
type MockBalance_GetCoinsSummary_Call struct {
	*mock.Call
}

// GetCoinsSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - walletCoinsIDs []int
//   - walletCoinsStrIDs map[int]string
func (_e *MockBalance_Expecter) GetCoinsSummary(ctx interface{}, userID interface{}, walletCoinsIDs interface{}, walletCoinsStrIDs interface{}) *MockBalance_GetCoinsSummary_Call {
	return &MockBalance_GetCoinsSummary_Call{Call: _e.mock.On("GetCoinsSummary", ctx, userID, walletCoinsIDs, walletCoinsStrIDs)}
}

func (_c *MockBalance_GetCoinsSummary_Call) Run(run func(ctx context.Context, userID int32, walletCoinsIDs []int, walletCoinsStrIDs map[int]string)) *MockBalance_GetCoinsSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].([]int), args[3].(map[int]string))
	})
	return _c
}

func (_c *MockBalance_GetCoinsSummary_Call) Return(_a0 []*model.CoinSummary, _a1 error) *MockBalance_GetCoinsSummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetCoinsSummary_Call) RunAndReturn(run func(context.Context, int32, []int, map[int]string) ([]*model.CoinSummary, error)) *MockBalance_GetCoinsSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetP2PAdminId provides a mock function with given fields: ctx
func (_m *MockBalance) GetP2PAdminId(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetP2PAdminId")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetP2PAdminId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetP2PAdminId'
type MockBalance_GetP2PAdminId_Call struct {
	*mock.Call
}

// GetP2PAdminId is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBalance_Expecter) GetP2PAdminId(ctx interface{}) *MockBalance_GetP2PAdminId_Call {
	return &MockBalance_GetP2PAdminId_Call{Call: _e.mock.On("GetP2PAdminId", ctx)}
}

func (_c *MockBalance_GetP2PAdminId_Call) Run(run func(ctx context.Context)) *MockBalance_GetP2PAdminId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockBalance_GetP2PAdminId_Call) Return(_a0 int, _a1 error) *MockBalance_GetP2PAdminId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetP2PAdminId_Call) RunAndReturn(run func(context.Context) (int, error)) *MockBalance_GetP2PAdminId_Call {
	_c.Call.Return(run)
	return _c
}

// GetPaid provides a mock function with given fields: ctx, userID, coinID, from, to
func (_m *MockBalance) GetPaid(ctx context.Context, userID int32, coinID int, from time.Time, to time.Time) (decimal.Decimal, error) {
	ret := _m.Called(ctx, userID, coinID, from, to)

	if len(ret) == 0 {
		panic("no return value specified for GetPaid")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int, time.Time, time.Time) (decimal.Decimal, error)); ok {
		return rf(ctx, userID, coinID, from, to)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int, time.Time, time.Time) decimal.Decimal); ok {
		r0 = rf(ctx, userID, coinID, from, to)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int, time.Time, time.Time) error); ok {
		r1 = rf(ctx, userID, coinID, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetPaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPaid'
type MockBalance_GetPaid_Call struct {
	*mock.Call
}

// GetPaid is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - coinID int
//   - from time.Time
//   - to time.Time
func (_e *MockBalance_Expecter) GetPaid(ctx interface{}, userID interface{}, coinID interface{}, from interface{}, to interface{}) *MockBalance_GetPaid_Call {
	return &MockBalance_GetPaid_Call{Call: _e.mock.On("GetPaid", ctx, userID, coinID, from, to)}
}

func (_c *MockBalance_GetPaid_Call) Run(run func(ctx context.Context, userID int32, coinID int, from time.Time, to time.Time)) *MockBalance_GetPaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int), args[3].(time.Time), args[4].(time.Time))
	})
	return _c
}

func (_c *MockBalance_GetPaid_Call) Return(_a0 decimal.Decimal, _a1 error) *MockBalance_GetPaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetPaid_Call) RunAndReturn(run func(context.Context, int32, int, time.Time, time.Time) (decimal.Decimal, error)) *MockBalance_GetPaid_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByID provides a mock function with given fields: ctx, id
func (_m *MockBalance) GetTransactionByID(ctx context.Context, id int) (*model.TransactionSelectionWithBlock, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 *model.TransactionSelectionWithBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*model.TransactionSelectionWithBlock, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *model.TransactionSelectionWithBlock); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TransactionSelectionWithBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetTransactionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByID'
type MockBalance_GetTransactionByID_Call struct {
	*mock.Call
}

// GetTransactionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockBalance_Expecter) GetTransactionByID(ctx interface{}, id interface{}) *MockBalance_GetTransactionByID_Call {
	return &MockBalance_GetTransactionByID_Call{Call: _e.mock.On("GetTransactionByID", ctx, id)}
}

func (_c *MockBalance_GetTransactionByID_Call) Run(run func(ctx context.Context, id int)) *MockBalance_GetTransactionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockBalance_GetTransactionByID_Call) Return(_a0 *model.TransactionSelectionWithBlock, _a1 error) *MockBalance_GetTransactionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetTransactionByID_Call) RunAndReturn(run func(context.Context, int) (*model.TransactionSelectionWithBlock, error)) *MockBalance_GetTransactionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByIDs provides a mock function with given fields: ctx, sqlTx, ids
func (_m *MockBalance) GetTransactionByIDs(ctx context.Context, sqlTx pgx.Tx, ids ...int64) ([]*model.Transaction, error) {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, sqlTx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByIDs")
	}

	var r0 []*model.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, ...int64) ([]*model.Transaction, error)); ok {
		return rf(ctx, sqlTx, ids...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgx.Tx, ...int64) []*model.Transaction); ok {
		r0 = rf(ctx, sqlTx, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgx.Tx, ...int64) error); ok {
		r1 = rf(ctx, sqlTx, ids...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetTransactionByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByIDs'
type MockBalance_GetTransactionByIDs_Call struct {
	*mock.Call
}

// GetTransactionByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - sqlTx pgx.Tx
//   - ids ...int64
func (_e *MockBalance_Expecter) GetTransactionByIDs(ctx interface{}, sqlTx interface{}, ids ...interface{}) *MockBalance_GetTransactionByIDs_Call {
	return &MockBalance_GetTransactionByIDs_Call{Call: _e.mock.On("GetTransactionByIDs",
		append([]interface{}{ctx, sqlTx}, ids...)...)}
}

func (_c *MockBalance_GetTransactionByIDs_Call) Run(run func(ctx context.Context, sqlTx pgx.Tx, ids ...int64)) *MockBalance_GetTransactionByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(pgx.Tx), variadicArgs...)
	})
	return _c
}

func (_c *MockBalance_GetTransactionByIDs_Call) Return(_a0 []*model.Transaction, _a1 error) *MockBalance_GetTransactionByIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetTransactionByIDs_Call) RunAndReturn(run func(context.Context, pgx.Tx, ...int64) ([]*model.Transaction, error)) *MockBalance_GetTransactionByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionIDByAction provides a mock function with given fields: ctx, actionID, txType, amount
func (_m *MockBalance) GetTransactionIDByAction(ctx context.Context, actionID string, txType int, amount string) (int, error) {
	ret := _m.Called(ctx, actionID, txType, amount)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionIDByAction")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (int, error)); ok {
		return rf(ctx, actionID, txType, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) int); ok {
		r0 = rf(ctx, actionID, txType, amount)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, actionID, txType, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetTransactionIDByAction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionIDByAction'
type MockBalance_GetTransactionIDByAction_Call struct {
	*mock.Call
}

// GetTransactionIDByAction is a helper method to define mock.On call
//   - ctx context.Context
//   - actionID string
//   - txType int
//   - amount string
func (_e *MockBalance_Expecter) GetTransactionIDByAction(ctx interface{}, actionID interface{}, txType interface{}, amount interface{}) *MockBalance_GetTransactionIDByAction_Call {
	return &MockBalance_GetTransactionIDByAction_Call{Call: _e.mock.On("GetTransactionIDByAction", ctx, actionID, txType, amount)}
}

func (_c *MockBalance_GetTransactionIDByAction_Call) Run(run func(ctx context.Context, actionID string, txType int, amount string)) *MockBalance_GetTransactionIDByAction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *MockBalance_GetTransactionIDByAction_Call) Return(_a0 int, _a1 error) *MockBalance_GetTransactionIDByAction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetTransactionIDByAction_Call) RunAndReturn(run func(context.Context, string, int, string) (int, error)) *MockBalance_GetTransactionIDByAction_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionsByActionID provides a mock function with given fields: ctx, actionID
func (_m *MockBalance) GetTransactionsByActionID(ctx context.Context, actionID string) ([]*model.Transaction, error) {
	ret := _m.Called(ctx, actionID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionsByActionID")
	}

	var r0 []*model.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*model.Transaction, error)); ok {
		return rf(ctx, actionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.Transaction); ok {
		r0 = rf(ctx, actionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, actionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetTransactionsByActionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionsByActionID'
type MockBalance_GetTransactionsByActionID_Call struct {
	*mock.Call
}

// GetTransactionsByActionID is a helper method to define mock.On call
//   - ctx context.Context
//   - actionID string
func (_e *MockBalance_Expecter) GetTransactionsByActionID(ctx interface{}, actionID interface{}) *MockBalance_GetTransactionsByActionID_Call {
	return &MockBalance_GetTransactionsByActionID_Call{Call: _e.mock.On("GetTransactionsByActionID", ctx, actionID)}
}

func (_c *MockBalance_GetTransactionsByActionID_Call) Run(run func(ctx context.Context, actionID string)) *MockBalance_GetTransactionsByActionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockBalance_GetTransactionsByActionID_Call) Return(_a0 []*model.Transaction, _a1 error) *MockBalance_GetTransactionsByActionID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetTransactionsByActionID_Call) RunAndReturn(run func(context.Context, string) ([]*model.Transaction, error)) *MockBalance_GetTransactionsByActionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountIDByNewID provides a mock function with given fields: ctx, userID, accountType, coinID
func (_m *MockBalance) GetUserAccountIDByNewID(ctx context.Context, userID uuid.UUID, accountType enum.AccountTypeId, coinID int) (int, error) {
	ret := _m.Called(ctx, userID, accountType, coinID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountIDByNewID")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, enum.AccountTypeId, int) (int, error)); ok {
		return rf(ctx, userID, accountType, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, enum.AccountTypeId, int) int); ok {
		r0 = rf(ctx, userID, accountType, coinID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, enum.AccountTypeId, int) error); ok {
		r1 = rf(ctx, userID, accountType, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetUserAccountIDByNewID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountIDByNewID'
type MockBalance_GetUserAccountIDByNewID_Call struct {
	*mock.Call
}

// GetUserAccountIDByNewID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - accountType enum.AccountTypeId
//   - coinID int
func (_e *MockBalance_Expecter) GetUserAccountIDByNewID(ctx interface{}, userID interface{}, accountType interface{}, coinID interface{}) *MockBalance_GetUserAccountIDByNewID_Call {
	return &MockBalance_GetUserAccountIDByNewID_Call{Call: _e.mock.On("GetUserAccountIDByNewID", ctx, userID, accountType, coinID)}
}

func (_c *MockBalance_GetUserAccountIDByNewID_Call) Run(run func(ctx context.Context, userID uuid.UUID, accountType enum.AccountTypeId, coinID int)) *MockBalance_GetUserAccountIDByNewID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(enum.AccountTypeId), args[3].(int))
	})
	return _c
}

func (_c *MockBalance_GetUserAccountIDByNewID_Call) Return(_a0 int, _a1 error) *MockBalance_GetUserAccountIDByNewID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetUserAccountIDByNewID_Call) RunAndReturn(run func(context.Context, uuid.UUID, enum.AccountTypeId, int) (int, error)) *MockBalance_GetUserAccountIDByNewID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountIDByOldID provides a mock function with given fields: ctx, userID, accountType, coinID
func (_m *MockBalance) GetUserAccountIDByOldID(ctx context.Context, userID int32, accountType enum.AccountTypeId, coinID int) (int, error) {
	ret := _m.Called(ctx, userID, accountType, coinID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountIDByOldID")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, enum.AccountTypeId, int) (int, error)); ok {
		return rf(ctx, userID, accountType, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, enum.AccountTypeId, int) int); ok {
		r0 = rf(ctx, userID, accountType, coinID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, enum.AccountTypeId, int) error); ok {
		r1 = rf(ctx, userID, accountType, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_GetUserAccountIDByOldID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountIDByOldID'
type MockBalance_GetUserAccountIDByOldID_Call struct {
	*mock.Call
}

// GetUserAccountIDByOldID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int32
//   - accountType enum.AccountTypeId
//   - coinID int
func (_e *MockBalance_Expecter) GetUserAccountIDByOldID(ctx interface{}, userID interface{}, accountType interface{}, coinID interface{}) *MockBalance_GetUserAccountIDByOldID_Call {
	return &MockBalance_GetUserAccountIDByOldID_Call{Call: _e.mock.On("GetUserAccountIDByOldID", ctx, userID, accountType, coinID)}
}

func (_c *MockBalance_GetUserAccountIDByOldID_Call) Run(run func(ctx context.Context, userID int32, accountType enum.AccountTypeId, coinID int)) *MockBalance_GetUserAccountIDByOldID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(enum.AccountTypeId), args[3].(int))
	})
	return _c
}

func (_c *MockBalance_GetUserAccountIDByOldID_Call) Return(_a0 int, _a1 error) *MockBalance_GetUserAccountIDByOldID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_GetUserAccountIDByOldID_Call) RunAndReturn(run func(context.Context, int32, enum.AccountTypeId, int) (int, error)) *MockBalance_GetUserAccountIDByOldID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserIDsByAccountID provides a mock function with given fields: ctx, accountID
func (_m *MockBalance) GetUserIDsByAccountID(ctx context.Context, accountID int) (uuid.UUID, int32, int32, error) {
	ret := _m.Called(ctx, accountID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserIDsByAccountID")
	}

	var r0 uuid.UUID
	var r1 int32
	var r2 int32
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (uuid.UUID, int32, int32, error)); ok {
		return rf(ctx, accountID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) uuid.UUID); ok {
		r0 = rf(ctx, accountID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) int32); ok {
		r1 = rf(ctx, accountID)
	} else {
		r1 = ret.Get(1).(int32)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int) int32); ok {
		r2 = rf(ctx, accountID)
	} else {
		r2 = ret.Get(2).(int32)
	}

	if rf, ok := ret.Get(3).(func(context.Context, int) error); ok {
		r3 = rf(ctx, accountID)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockBalance_GetUserIDsByAccountID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserIDsByAccountID'
type MockBalance_GetUserIDsByAccountID_Call struct {
	*mock.Call
}

// GetUserIDsByAccountID is a helper method to define mock.On call
//   - ctx context.Context
//   - accountID int
func (_e *MockBalance_Expecter) GetUserIDsByAccountID(ctx interface{}, accountID interface{}) *MockBalance_GetUserIDsByAccountID_Call {
	return &MockBalance_GetUserIDsByAccountID_Call{Call: _e.mock.On("GetUserIDsByAccountID", ctx, accountID)}
}

func (_c *MockBalance_GetUserIDsByAccountID_Call) Run(run func(ctx context.Context, accountID int)) *MockBalance_GetUserIDsByAccountID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockBalance_GetUserIDsByAccountID_Call) Return(_a0 uuid.UUID, _a1 int32, _a2 int32, _a3 error) *MockBalance_GetUserIDsByAccountID_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockBalance_GetUserIDsByAccountID_Call) RunAndReturn(run func(context.Context, int) (uuid.UUID, int32, int32, error)) *MockBalance_GetUserIDsByAccountID_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function with given fields: ctx, userID, coinID, accountTypeID, totalBalance
func (_m *MockBalance) View(ctx context.Context, userID int64, coinID int64, accountTypeID enum.AccountTypeId, totalBalance bool) (decimal.Decimal, error) {
	ret := _m.Called(ctx, userID, coinID, accountTypeID, totalBalance)

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, enum.AccountTypeId, bool) (decimal.Decimal, error)); ok {
		return rf(ctx, userID, coinID, accountTypeID, totalBalance)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, enum.AccountTypeId, bool) decimal.Decimal); ok {
		r0 = rf(ctx, userID, coinID, accountTypeID, totalBalance)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, enum.AccountTypeId, bool) error); ok {
		r1 = rf(ctx, userID, coinID, accountTypeID, totalBalance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBalance_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type MockBalance_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - coinID int64
//   - accountTypeID enum.AccountTypeId
//   - totalBalance bool
func (_e *MockBalance_Expecter) View(ctx interface{}, userID interface{}, coinID interface{}, accountTypeID interface{}, totalBalance interface{}) *MockBalance_View_Call {
	return &MockBalance_View_Call{Call: _e.mock.On("View", ctx, userID, coinID, accountTypeID, totalBalance)}
}

func (_c *MockBalance_View_Call) Run(run func(ctx context.Context, userID int64, coinID int64, accountTypeID enum.AccountTypeId, totalBalance bool)) *MockBalance_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(enum.AccountTypeId), args[4].(bool))
	})
	return _c
}

func (_c *MockBalance_View_Call) Return(_a0 decimal.Decimal, _a1 error) *MockBalance_View_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBalance_View_Call) RunAndReturn(run func(context.Context, int64, int64, enum.AccountTypeId, bool) (decimal.Decimal, error)) *MockBalance_View_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBalance creates a new instance of MockBalance. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBalance(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBalance {
	mock := &MockBalance{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.43.2. DO NOT EDIT.

package repository

import (
	context "context"

	decimal "github.com/shopspring/decimal"
	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/service/accounting/model"

	time "time"
)

// MockPayoutRepository is an autogenerated mock type for the PayoutRepository type
type MockPayoutRepository struct {
	mock.Mock
}

type MockPayoutRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPayoutRepository) EXPECT() *MockPayoutRepository_Expecter {
	return &MockPayoutRepository_Expecter{mock: &_m.Mock}
}

// CheckFreePayoutTransaction provides a mock function with given fields: ctx, accountId, transactionId
func (_m *MockPayoutRepository) CheckFreePayoutTransaction(ctx context.Context, accountId int64, transactionId int64) (decimal.Decimal, error) {
	ret := _m.Called(ctx, accountId, transactionId)

	if len(ret) == 0 {
		panic("no return value specified for CheckFreePayoutTransaction")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) (decimal.Decimal, error)); ok {
		return rf(ctx, accountId, transactionId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) decimal.Decimal); ok {
		r0 = rf(ctx, accountId, transactionId)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, accountId, transactionId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_CheckFreePayoutTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckFreePayoutTransaction'
type MockPayoutRepository_CheckFreePayoutTransaction_Call struct {
	*mock.Call
}

// CheckFreePayoutTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId int64
//   - transactionId int64
func (_e *MockPayoutRepository_Expecter) CheckFreePayoutTransaction(ctx interface{}, accountId interface{}, transactionId interface{}) *MockPayoutRepository_CheckFreePayoutTransaction_Call {
	return &MockPayoutRepository_CheckFreePayoutTransaction_Call{Call: _e.mock.On("CheckFreePayoutTransaction", ctx, accountId, transactionId)}
}

func (_c *MockPayoutRepository_CheckFreePayoutTransaction_Call) Run(run func(ctx context.Context, accountId int64, transactionId int64)) *MockPayoutRepository_CheckFreePayoutTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockPayoutRepository_CheckFreePayoutTransaction_Call) Return(_a0 decimal.Decimal, _a1 error) *MockPayoutRepository_CheckFreePayoutTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_CheckFreePayoutTransaction_Call) RunAndReturn(run func(context.Context, int64, int64) (decimal.Decimal, error)) *MockPayoutRepository_CheckFreePayoutTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIncomeOperations provides a mock function with given fields: ctx, queryParams
func (_m *MockPayoutRepository) CheckIncomeOperations(ctx context.Context, queryParams model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for CheckIncomeOperations")
	}

	var r0 []*model.IncomeWithFee
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckIncomeOperationsQuery) []*model.IncomeWithFee); ok {
		r0 = rf(ctx, queryParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.IncomeWithFee)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.CheckIncomeOperationsQuery) error); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_CheckIncomeOperations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIncomeOperations'
type MockPayoutRepository_CheckIncomeOperations_Call struct {
	*mock.Call
}

// CheckIncomeOperations is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams model.CheckIncomeOperationsQuery
func (_e *MockPayoutRepository_Expecter) CheckIncomeOperations(ctx interface{}, queryParams interface{}) *MockPayoutRepository_CheckIncomeOperations_Call {
	return &MockPayoutRepository_CheckIncomeOperations_Call{Call: _e.mock.On("CheckIncomeOperations", ctx, queryParams)}
}

func (_c *MockPayoutRepository_CheckIncomeOperations_Call) Run(run func(ctx context.Context, queryParams model.CheckIncomeOperationsQuery)) *MockPayoutRepository_CheckIncomeOperations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.CheckIncomeOperationsQuery))
	})
	return _c
}

func (_c *MockPayoutRepository_CheckIncomeOperations_Call) Return(_a0 []*model.IncomeWithFee, _a1 error) *MockPayoutRepository_CheckIncomeOperations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_CheckIncomeOperations_Call) RunAndReturn(run func(context.Context, model.CheckIncomeOperationsQuery) ([]*model.IncomeWithFee, error)) *MockPayoutRepository_CheckIncomeOperations_Call {
	_c.Call.Return(run)
	return _c
}

// CheckOthers provides a mock function with given fields: ctx, queryParams
func (_m *MockPayoutRepository) CheckOthers(ctx context.Context, queryParams model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for CheckOthers")
	}

	var r0 []*model.OtherOperationsWithTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.CheckOtherQuery) []*model.OtherOperationsWithTransaction); ok {
		r0 = rf(ctx, queryParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OtherOperationsWithTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.CheckOtherQuery) error); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_CheckOthers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckOthers'
type MockPayoutRepository_CheckOthers_Call struct {
	*mock.Call
}

// CheckOthers is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams model.CheckOtherQuery
func (_e *MockPayoutRepository_Expecter) CheckOthers(ctx interface{}, queryParams interface{}) *MockPayoutRepository_CheckOthers_Call {
	return &MockPayoutRepository_CheckOthers_Call{Call: _e.mock.On("CheckOthers", ctx, queryParams)}
}

func (_c *MockPayoutRepository_CheckOthers_Call) Run(run func(ctx context.Context, queryParams model.CheckOtherQuery)) *MockPayoutRepository_CheckOthers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.CheckOtherQuery))
	})
	return _c
}

func (_c *MockPayoutRepository_CheckOthers_Call) Return(_a0 []*model.OtherOperationsWithTransaction, _a1 error) *MockPayoutRepository_CheckOthers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_CheckOthers_Call) RunAndReturn(run func(context.Context, model.CheckOtherQuery) ([]*model.OtherOperationsWithTransaction, error)) *MockPayoutRepository_CheckOthers_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPayoutBlockStatus provides a mock function with given fields: ctx, transactionIds
func (_m *MockPayoutRepository) CheckPayoutBlockStatus(ctx context.Context, transactionIds []int64) ([]*model.PayoutBlockStatus, error) {
	ret := _m.Called(ctx, transactionIds)

	if len(ret) == 0 {
		panic("no return value specified for CheckPayoutBlockStatus")
	}

	var r0 []*model.PayoutBlockStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []int64) ([]*model.PayoutBlockStatus, error)); ok {
		return rf(ctx, transactionIds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []int64) []*model.PayoutBlockStatus); ok {
		r0 = rf(ctx, transactionIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutBlockStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []int64) error); ok {
		r1 = rf(ctx, transactionIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_CheckPayoutBlockStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPayoutBlockStatus'
type MockPayoutRepository_CheckPayoutBlockStatus_Call struct {
	*mock.Call
}

// CheckPayoutBlockStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionIds []int64
func (_e *MockPayoutRepository_Expecter) CheckPayoutBlockStatus(ctx interface{}, transactionIds interface{}) *MockPayoutRepository_CheckPayoutBlockStatus_Call {
	return &MockPayoutRepository_CheckPayoutBlockStatus_Call{Call: _e.mock.On("CheckPayoutBlockStatus", ctx, transactionIds)}
}

func (_c *MockPayoutRepository_CheckPayoutBlockStatus_Call) Run(run func(ctx context.Context, transactionIds []int64)) *MockPayoutRepository_CheckPayoutBlockStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]int64))
	})
	return _c
}

func (_c *MockPayoutRepository_CheckPayoutBlockStatus_Call) Return(_a0 []*model.PayoutBlockStatus, _a1 error) *MockPayoutRepository_CheckPayoutBlockStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_CheckPayoutBlockStatus_Call) RunAndReturn(run func(context.Context, []int64) ([]*model.PayoutBlockStatus, error)) *MockPayoutRepository_CheckPayoutBlockStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetAveragePaid provides a mock function with given fields: ctx, queryParams
func (_m *MockPayoutRepository) GetAveragePaid(ctx context.Context, queryParams model.AveragePaidQuery) (decimal.Decimal, error) {
	ret := _m.Called(ctx, queryParams)

	if len(ret) == 0 {
		panic("no return value specified for GetAveragePaid")
	}

	var r0 decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AveragePaidQuery) (decimal.Decimal, error)); ok {
		return rf(ctx, queryParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.AveragePaidQuery) decimal.Decimal); ok {
		r0 = rf(ctx, queryParams)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.AveragePaidQuery) error); ok {
		r1 = rf(ctx, queryParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetAveragePaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAveragePaid'
type MockPayoutRepository_GetAveragePaid_Call struct {
	*mock.Call
}

// GetAveragePaid is a helper method to define mock.On call
//   - ctx context.Context
//   - queryParams model.AveragePaidQuery
func (_e *MockPayoutRepository_Expecter) GetAveragePaid(ctx interface{}, queryParams interface{}) *MockPayoutRepository_GetAveragePaid_Call {
	return &MockPayoutRepository_GetAveragePaid_Call{Call: _e.mock.On("GetAveragePaid", ctx, queryParams)}
}

func (_c *MockPayoutRepository_GetAveragePaid_Call) Run(run func(ctx context.Context, queryParams model.AveragePaidQuery)) *MockPayoutRepository_GetAveragePaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.AveragePaidQuery))
	})
	return _c
}

func (_c *MockPayoutRepository_GetAveragePaid_Call) Return(_a0 decimal.Decimal, _a1 error) *MockPayoutRepository_GetAveragePaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetAveragePaid_Call) RunAndReturn(run func(context.Context, model.AveragePaidQuery) (decimal.Decimal, error)) *MockPayoutRepository_GetAveragePaid_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsBlock provides a mock function with given fields: ctx, coinID, username, isService
func (_m *MockPayoutRepository) GetCurrentPayoutsBlock(ctx context.Context, coinID int64, username string, isService bool) ([]*model.PayoutBlockTransaction, error) {
	ret := _m.Called(ctx, coinID, username, isService)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsBlock")
	}

	var r0 []*model.PayoutBlockTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, bool) ([]*model.PayoutBlockTransaction, error)); ok {
		return rf(ctx, coinID, username, isService)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, bool) []*model.PayoutBlockTransaction); ok {
		r0 = rf(ctx, coinID, username, isService)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutBlockTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, bool) error); ok {
		r1 = rf(ctx, coinID, username, isService)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetCurrentPayoutsBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsBlock'
type MockPayoutRepository_GetCurrentPayoutsBlock_Call struct {
	*mock.Call
}

// GetCurrentPayoutsBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - username string
//   - isService bool
func (_e *MockPayoutRepository_Expecter) GetCurrentPayoutsBlock(ctx interface{}, coinID interface{}, username interface{}, isService interface{}) *MockPayoutRepository_GetCurrentPayoutsBlock_Call {
	return &MockPayoutRepository_GetCurrentPayoutsBlock_Call{Call: _e.mock.On("GetCurrentPayoutsBlock", ctx, coinID, username, isService)}
}

func (_c *MockPayoutRepository_GetCurrentPayoutsBlock_Call) Run(run func(ctx context.Context, coinID int64, username string, isService bool)) *MockPayoutRepository_GetCurrentPayoutsBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockPayoutRepository_GetCurrentPayoutsBlock_Call) Return(_a0 []*model.PayoutBlockTransaction, _a1 error) *MockPayoutRepository_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetCurrentPayoutsBlock_Call) RunAndReturn(run func(context.Context, int64, string, bool) ([]*model.PayoutBlockTransaction, error)) *MockPayoutRepository_GetCurrentPayoutsBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentPayoutsList provides a mock function with given fields: ctx, coinID, paymentTransactionType
func (_m *MockPayoutRepository) GetCurrentPayoutsList(ctx context.Context, coinID int64, paymentTransactionType int64) ([]*model.PayoutWithCalculation, error) {
	ret := _m.Called(ctx, coinID, paymentTransactionType)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentPayoutsList")
	}

	var r0 []*model.PayoutWithCalculation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) ([]*model.PayoutWithCalculation, error)); ok {
		return rf(ctx, coinID, paymentTransactionType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) []*model.PayoutWithCalculation); ok {
		r0 = rf(ctx, coinID, paymentTransactionType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutWithCalculation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, coinID, paymentTransactionType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetCurrentPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentPayoutsList'
type MockPayoutRepository_GetCurrentPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - paymentTransactionType int64
func (_e *MockPayoutRepository_Expecter) GetCurrentPayoutsList(ctx interface{}, coinID interface{}, paymentTransactionType interface{}) *MockPayoutRepository_GetCurrentPayoutsList_Call {
	return &MockPayoutRepository_GetCurrentPayoutsList_Call{Call: _e.mock.On("GetCurrentPayoutsList", ctx, coinID, paymentTransactionType)}
}

func (_c *MockPayoutRepository_GetCurrentPayoutsList_Call) Run(run func(ctx context.Context, coinID int64, paymentTransactionType int64)) *MockPayoutRepository_GetCurrentPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockPayoutRepository_GetCurrentPayoutsList_Call) Return(_a0 []*model.PayoutWithCalculation, _a1 error) *MockPayoutRepository_GetCurrentPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetCurrentPayoutsList_Call) RunAndReturn(run func(context.Context, int64, int64) ([]*model.PayoutWithCalculation, error)) *MockPayoutRepository_GetCurrentPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentReferralsPayoutsList provides a mock function with given fields: ctx, coinID, referralId, paymentTransactionType
func (_m *MockPayoutRepository) GetCurrentReferralsPayoutsList(ctx context.Context, coinID int64, referralId int64, paymentTransactionType int64) ([]*model.PayoutWithCalculation, error) {
	ret := _m.Called(ctx, coinID, referralId, paymentTransactionType)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentReferralsPayoutsList")
	}

	var r0 []*model.PayoutWithCalculation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, int64) ([]*model.PayoutWithCalculation, error)); ok {
		return rf(ctx, coinID, referralId, paymentTransactionType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, int64) []*model.PayoutWithCalculation); ok {
		r0 = rf(ctx, coinID, referralId, paymentTransactionType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutWithCalculation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, int64) error); ok {
		r1 = rf(ctx, coinID, referralId, paymentTransactionType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetCurrentReferralsPayoutsList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentReferralsPayoutsList'
type MockPayoutRepository_GetCurrentReferralsPayoutsList_Call struct {
	*mock.Call
}

// GetCurrentReferralsPayoutsList is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - referralId int64
//   - paymentTransactionType int64
func (_e *MockPayoutRepository_Expecter) GetCurrentReferralsPayoutsList(ctx interface{}, coinID interface{}, referralId interface{}, paymentTransactionType interface{}) *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call {
	return &MockPayoutRepository_GetCurrentReferralsPayoutsList_Call{Call: _e.mock.On("GetCurrentReferralsPayoutsList", ctx, coinID, referralId, paymentTransactionType)}
}

func (_c *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call) Run(run func(ctx context.Context, coinID int64, referralId int64, paymentTransactionType int64)) *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call) Return(_a0 []*model.PayoutWithCalculation, _a1 error) *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call) RunAndReturn(run func(context.Context, int64, int64, int64) ([]*model.PayoutWithCalculation, error)) *MockPayoutRepository_GetCurrentReferralsPayoutsList_Call {
	_c.Call.Return(run)
	return _c
}

// GetFreePayouts provides a mock function with given fields: ctx, coinID
func (_m *MockPayoutRepository) GetFreePayouts(ctx context.Context, coinID int64) ([]*model.FreePayout, error) {
	ret := _m.Called(ctx, coinID)

	if len(ret) == 0 {
		panic("no return value specified for GetFreePayouts")
	}

	var r0 []*model.FreePayout
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]*model.FreePayout, error)); ok {
		return rf(ctx, coinID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []*model.FreePayout); ok {
		r0 = rf(ctx, coinID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.FreePayout)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, coinID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetFreePayouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFreePayouts'
type MockPayoutRepository_GetFreePayouts_Call struct {
	*mock.Call
}

// GetFreePayouts is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
func (_e *MockPayoutRepository_Expecter) GetFreePayouts(ctx interface{}, coinID interface{}) *MockPayoutRepository_GetFreePayouts_Call {
	return &MockPayoutRepository_GetFreePayouts_Call{Call: _e.mock.On("GetFreePayouts", ctx, coinID)}
}

func (_c *MockPayoutRepository_GetFreePayouts_Call) Run(run func(ctx context.Context, coinID int64)) *MockPayoutRepository_GetFreePayouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPayoutRepository_GetFreePayouts_Call) Return(_a0 []*model.FreePayout, _a1 error) *MockPayoutRepository_GetFreePayouts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetFreePayouts_Call) RunAndReturn(run func(context.Context, int64) ([]*model.FreePayout, error)) *MockPayoutRepository_GetFreePayouts_Call {
	_c.Call.Return(run)
	return _c
}

// GetPayoutsForBlock provides a mock function with given fields: ctx, coinID, minPay, timestamp
func (_m *MockPayoutRepository) GetPayoutsForBlock(ctx context.Context, coinID int64, minPay float32, timestamp time.Time) ([]*model.PayoutForBlock, error) {
	ret := _m.Called(ctx, coinID, minPay, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for GetPayoutsForBlock")
	}

	var r0 []*model.PayoutForBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, float32, time.Time) ([]*model.PayoutForBlock, error)); ok {
		return rf(ctx, coinID, minPay, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, float32, time.Time) []*model.PayoutForBlock); ok {
		r0 = rf(ctx, coinID, minPay, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PayoutForBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, float32, time.Time) error); ok {
		r1 = rf(ctx, coinID, minPay, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetPayoutsForBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPayoutsForBlock'
type MockPayoutRepository_GetPayoutsForBlock_Call struct {
	*mock.Call
}

// GetPayoutsForBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - coinID int64
//   - minPay float32
//   - timestamp time.Time
func (_e *MockPayoutRepository_Expecter) GetPayoutsForBlock(ctx interface{}, coinID interface{}, minPay interface{}, timestamp interface{}) *MockPayoutRepository_GetPayoutsForBlock_Call {
	return &MockPayoutRepository_GetPayoutsForBlock_Call{Call: _e.mock.On("GetPayoutsForBlock", ctx, coinID, minPay, timestamp)}
}

func (_c *MockPayoutRepository_GetPayoutsForBlock_Call) Run(run func(ctx context.Context, coinID int64, minPay float32, timestamp time.Time)) *MockPayoutRepository_GetPayoutsForBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(float32), args[3].(time.Time))
	})
	return _c
}

func (_c *MockPayoutRepository_GetPayoutsForBlock_Call) Return(_a0 []*model.PayoutForBlock, _a1 error) *MockPayoutRepository_GetPayoutsForBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetPayoutsForBlock_Call) RunAndReturn(run func(context.Context, int64, float32, time.Time) ([]*model.PayoutForBlock, error)) *MockPayoutRepository_GetPayoutsForBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetServiceUserData provides a mock function with given fields: ctx, coinId, username, limit
func (_m *MockPayoutRepository) GetServiceUserData(ctx context.Context, coinId int64, username string, limit int64) ([]*model.ServiceUserBlock, error) {
	ret := _m.Called(ctx, coinId, username, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetServiceUserData")
	}

	var r0 []*model.ServiceUserBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64) ([]*model.ServiceUserBlock, error)); ok {
		return rf(ctx, coinId, username, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int64) []*model.ServiceUserBlock); ok {
		r0 = rf(ctx, coinId, username, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.ServiceUserBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, int64) error); ok {
		r1 = rf(ctx, coinId, username, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayoutRepository_GetServiceUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServiceUserData'
type MockPayoutRepository_GetServiceUserData_Call struct {
	*mock.Call
}

// GetServiceUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - coinId int64
//   - username string
//   - limit int64
func (_e *MockPayoutRepository_Expecter) GetServiceUserData(ctx interface{}, coinId interface{}, username interface{}, limit interface{}) *MockPayoutRepository_GetServiceUserData_Call {
	return &MockPayoutRepository_GetServiceUserData_Call{Call: _e.mock.On("GetServiceUserData", ctx, coinId, username, limit)}
}

func (_c *MockPayoutRepository_GetServiceUserData_Call) Run(run func(ctx context.Context, coinId int64, username string, limit int64)) *MockPayoutRepository_GetServiceUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockPayoutRepository_GetServiceUserData_Call) Return(_a0 []*model.ServiceUserBlock, _a1 error) *MockPayoutRepository_GetServiceUserData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayoutRepository_GetServiceUserData_Call) RunAndReturn(run func(context.Context, int64, string, int64) ([]*model.ServiceUserBlock, error)) *MockPayoutRepository_GetServiceUserData_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPayoutRepository creates a new instance of MockPayoutRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPayoutRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPayoutRepository {
	mock := &MockPayoutRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.43.2. DO NOT EDIT.

package repository

import (
	context "context"

	enum "code.emcdtech.com/emcd/service/accounting/model/enum"
	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/service/accounting/model"

	uuid "github.com/google/uuid"
)

// MockUserAccountRepository is an autogenerated mock type for the UserAccountRepository type
type MockUserAccountRepository struct {
	mock.Mock
}

type MockUserAccountRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserAccountRepository) EXPECT() *MockUserAccountRepository_Expecter {
	return &MockUserAccountRepository_Expecter{mock: &_m.Mock}
}

// CreateDefaultUserAccounts provides a mock function with given fields: ctx, userId, userIdNew, minPay, fee
func (_m *MockUserAccountRepository) CreateDefaultUserAccounts(ctx context.Context, userId int32, userIdNew uuid.UUID, minPay float64, fee float64) (model.UserAccounts, error) {
	ret := _m.Called(ctx, userId, userIdNew, minPay, fee)

	if len(ret) == 0 {
		panic("no return value specified for CreateDefaultUserAccounts")
	}

	var r0 model.UserAccounts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, float64, float64) (model.UserAccounts, error)); ok {
		return rf(ctx, userId, userIdNew, minPay, fee)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, float64, float64) model.UserAccounts); ok {
		r0 = rf(ctx, userId, userIdNew, minPay, fee)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.UserAccounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, uuid.UUID, float64, float64) error); ok {
		r1 = rf(ctx, userId, userIdNew, minPay, fee)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_CreateDefaultUserAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDefaultUserAccounts'
type MockUserAccountRepository_CreateDefaultUserAccounts_Call struct {
	*mock.Call
}

// CreateDefaultUserAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int32
//   - userIdNew uuid.UUID
//   - minPay float64
//   - fee float64
func (_e *MockUserAccountRepository_Expecter) CreateDefaultUserAccounts(ctx interface{}, userId interface{}, userIdNew interface{}, minPay interface{}, fee interface{}) *MockUserAccountRepository_CreateDefaultUserAccounts_Call {
	return &MockUserAccountRepository_CreateDefaultUserAccounts_Call{Call: _e.mock.On("CreateDefaultUserAccounts", ctx, userId, userIdNew, minPay, fee)}
}

func (_c *MockUserAccountRepository_CreateDefaultUserAccounts_Call) Run(run func(ctx context.Context, userId int32, userIdNew uuid.UUID, minPay float64, fee float64)) *MockUserAccountRepository_CreateDefaultUserAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(uuid.UUID), args[3].(float64), args[4].(float64))
	})
	return _c
}

func (_c *MockUserAccountRepository_CreateDefaultUserAccounts_Call) Return(_a0 model.UserAccounts, _a1 error) *MockUserAccountRepository_CreateDefaultUserAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_CreateDefaultUserAccounts_Call) RunAndReturn(run func(context.Context, int32, uuid.UUID, float64, float64) (model.UserAccounts, error)) *MockUserAccountRepository_CreateDefaultUserAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUserAccounts provides a mock function with given fields: ctx, userId, userIdNew, req
func (_m *MockUserAccountRepository) CreateUserAccounts(ctx context.Context, userId int32, userIdNew uuid.UUID, req model.UserAccounts) (model.UserAccounts, error) {
	ret := _m.Called(ctx, userId, userIdNew, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserAccounts")
	}

	var r0 model.UserAccounts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, model.UserAccounts) (model.UserAccounts, error)); ok {
		return rf(ctx, userId, userIdNew, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, model.UserAccounts) model.UserAccounts); ok {
		r0 = rf(ctx, userId, userIdNew, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.UserAccounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, uuid.UUID, model.UserAccounts) error); ok {
		r1 = rf(ctx, userId, userIdNew, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_CreateUserAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUserAccounts'
type MockUserAccountRepository_CreateUserAccounts_Call struct {
	*mock.Call
}

// CreateUserAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int32
//   - userIdNew uuid.UUID
//   - req model.UserAccounts
func (_e *MockUserAccountRepository_Expecter) CreateUserAccounts(ctx interface{}, userId interface{}, userIdNew interface{}, req interface{}) *MockUserAccountRepository_CreateUserAccounts_Call {
	return &MockUserAccountRepository_CreateUserAccounts_Call{Call: _e.mock.On("CreateUserAccounts", ctx, userId, userIdNew, req)}
}

func (_c *MockUserAccountRepository_CreateUserAccounts_Call) Run(run func(ctx context.Context, userId int32, userIdNew uuid.UUID, req model.UserAccounts)) *MockUserAccountRepository_CreateUserAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(uuid.UUID), args[3].(model.UserAccounts))
	})
	return _c
}

func (_c *MockUserAccountRepository_CreateUserAccounts_Call) Return(_a0 model.UserAccounts, _a1 error) *MockUserAccountRepository_CreateUserAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_CreateUserAccounts_Call) RunAndReturn(run func(context.Context, int32, uuid.UUID, model.UserAccounts) (model.UserAccounts, error)) *MockUserAccountRepository_CreateUserAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateUserAccount provides a mock function with given fields: ctx, req
func (_m *MockUserAccountRepository) GetOrCreateUserAccount(ctx context.Context, req *model.UserAccount) (*model.UserAccount, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateUserAccount")
	}

	var r0 *model.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.UserAccount) (*model.UserAccount, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.UserAccount) *model.UserAccount); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.UserAccount) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_GetOrCreateUserAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateUserAccount'
type MockUserAccountRepository_GetOrCreateUserAccount_Call struct {
	*mock.Call
}

// GetOrCreateUserAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - req *model.UserAccount
func (_e *MockUserAccountRepository_Expecter) GetOrCreateUserAccount(ctx interface{}, req interface{}) *MockUserAccountRepository_GetOrCreateUserAccount_Call {
	return &MockUserAccountRepository_GetOrCreateUserAccount_Call{Call: _e.mock.On("GetOrCreateUserAccount", ctx, req)}
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccount_Call) Run(run func(ctx context.Context, req *model.UserAccount)) *MockUserAccountRepository_GetOrCreateUserAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.UserAccount))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccount_Call) Return(_a0 *model.UserAccount, _a1 error) *MockUserAccountRepository_GetOrCreateUserAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccount_Call) RunAndReturn(run func(context.Context, *model.UserAccount) (*model.UserAccount, error)) *MockUserAccountRepository_GetOrCreateUserAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateUserAccountByArgs provides a mock function with given fields: ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee
func (_m *MockUserAccountRepository) GetOrCreateUserAccountByArgs(ctx context.Context, userId int32, userIdNew uuid.UUID, coinIdNew string, accountTypeId enum.AccountTypeId, minPay float64, fee float64) (*model.UserAccount, error) {
	ret := _m.Called(ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateUserAccountByArgs")
	}

	var r0 *model.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, string, enum.AccountTypeId, float64, float64) (*model.UserAccount, error)); ok {
		return rf(ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, uuid.UUID, string, enum.AccountTypeId, float64, float64) *model.UserAccount); ok {
		r0 = rf(ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, uuid.UUID, string, enum.AccountTypeId, float64, float64) error); ok {
		r1 = rf(ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateUserAccountByArgs'
type MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call struct {
	*mock.Call
}

// GetOrCreateUserAccountByArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int32
//   - userIdNew uuid.UUID
//   - coinIdNew string
//   - accountTypeId enum.AccountTypeId
//   - minPay float64
//   - fee float64
func (_e *MockUserAccountRepository_Expecter) GetOrCreateUserAccountByArgs(ctx interface{}, userId interface{}, userIdNew interface{}, coinIdNew interface{}, accountTypeId interface{}, minPay interface{}, fee interface{}) *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call {
	return &MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call{Call: _e.mock.On("GetOrCreateUserAccountByArgs", ctx, userId, userIdNew, coinIdNew, accountTypeId, minPay, fee)}
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call) Run(run func(ctx context.Context, userId int32, userIdNew uuid.UUID, coinIdNew string, accountTypeId enum.AccountTypeId, minPay float64, fee float64)) *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(uuid.UUID), args[3].(string), args[4].(enum.AccountTypeId), args[5].(float64), args[6].(float64))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call) Return(_a0 *model.UserAccount, _a1 error) *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call) RunAndReturn(run func(context.Context, int32, uuid.UUID, string, enum.AccountTypeId, float64, float64) (*model.UserAccount, error)) *MockUserAccountRepository_GetOrCreateUserAccountByArgs_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountByConstraint provides a mock function with given fields: ctx, userIdNew, coinIdNew, accountTypeId
func (_m *MockUserAccountRepository) GetUserAccountByConstraint(ctx context.Context, userIdNew uuid.UUID, coinIdNew string, accountTypeId enum.AccountTypeId) (*model.UserAccount, error) {
	ret := _m.Called(ctx, userIdNew, coinIdNew, accountTypeId)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountByConstraint")
	}

	var r0 *model.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, enum.AccountTypeId) (*model.UserAccount, error)); ok {
		return rf(ctx, userIdNew, coinIdNew, accountTypeId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, enum.AccountTypeId) *model.UserAccount); ok {
		r0 = rf(ctx, userIdNew, coinIdNew, accountTypeId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, enum.AccountTypeId) error); ok {
		r1 = rf(ctx, userIdNew, coinIdNew, accountTypeId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_GetUserAccountByConstraint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountByConstraint'
type MockUserAccountRepository_GetUserAccountByConstraint_Call struct {
	*mock.Call
}

// GetUserAccountByConstraint is a helper method to define mock.On call
//   - ctx context.Context
//   - userIdNew uuid.UUID
//   - coinIdNew string
//   - accountTypeId enum.AccountTypeId
func (_e *MockUserAccountRepository_Expecter) GetUserAccountByConstraint(ctx interface{}, userIdNew interface{}, coinIdNew interface{}, accountTypeId interface{}) *MockUserAccountRepository_GetUserAccountByConstraint_Call {
	return &MockUserAccountRepository_GetUserAccountByConstraint_Call{Call: _e.mock.On("GetUserAccountByConstraint", ctx, userIdNew, coinIdNew, accountTypeId)}
}

func (_c *MockUserAccountRepository_GetUserAccountByConstraint_Call) Run(run func(ctx context.Context, userIdNew uuid.UUID, coinIdNew string, accountTypeId enum.AccountTypeId)) *MockUserAccountRepository_GetUserAccountByConstraint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(enum.AccountTypeId))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountByConstraint_Call) Return(_a0 *model.UserAccount, _a1 error) *MockUserAccountRepository_GetUserAccountByConstraint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountByConstraint_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, enum.AccountTypeId) (*model.UserAccount, error)) *MockUserAccountRepository_GetUserAccountByConstraint_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountById provides a mock function with given fields: ctx, userId
func (_m *MockUserAccountRepository) GetUserAccountById(ctx context.Context, userId int32) (*model.UserAccount, error) {
	ret := _m.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountById")
	}

	var r0 *model.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (*model.UserAccount, error)); ok {
		return rf(ctx, userId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) *model.UserAccount); ok {
		r0 = rf(ctx, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, userId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_GetUserAccountById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountById'
type MockUserAccountRepository_GetUserAccountById_Call struct {
	*mock.Call
}

// GetUserAccountById is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int32
func (_e *MockUserAccountRepository_Expecter) GetUserAccountById(ctx interface{}, userId interface{}) *MockUserAccountRepository_GetUserAccountById_Call {
	return &MockUserAccountRepository_GetUserAccountById_Call{Call: _e.mock.On("GetUserAccountById", ctx, userId)}
}

func (_c *MockUserAccountRepository_GetUserAccountById_Call) Run(run func(ctx context.Context, userId int32)) *MockUserAccountRepository_GetUserAccountById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountById_Call) Return(_a0 *model.UserAccount, _a1 error) *MockUserAccountRepository_GetUserAccountById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountById_Call) RunAndReturn(run func(context.Context, int32) (*model.UserAccount, error)) *MockUserAccountRepository_GetUserAccountById_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountsByFilter provides a mock function with given fields: ctx, filter
func (_m *MockUserAccountRepository) GetUserAccountsByFilter(ctx context.Context, filter *model.UserAccountFilter) (*uint64, model.UserAccounts, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountsByFilter")
	}

	var r0 *uint64
	var r1 model.UserAccounts
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.UserAccountFilter) (*uint64, model.UserAccounts, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.UserAccountFilter) *uint64); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.UserAccountFilter) model.UserAccounts); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(model.UserAccounts)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.UserAccountFilter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserAccountRepository_GetUserAccountsByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountsByFilter'
type MockUserAccountRepository_GetUserAccountsByFilter_Call struct {
	*mock.Call
}

// GetUserAccountsByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.UserAccountFilter
func (_e *MockUserAccountRepository_Expecter) GetUserAccountsByFilter(ctx interface{}, filter interface{}) *MockUserAccountRepository_GetUserAccountsByFilter_Call {
	return &MockUserAccountRepository_GetUserAccountsByFilter_Call{Call: _e.mock.On("GetUserAccountsByFilter", ctx, filter)}
}

func (_c *MockUserAccountRepository_GetUserAccountsByFilter_Call) Run(run func(ctx context.Context, filter *model.UserAccountFilter)) *MockUserAccountRepository_GetUserAccountsByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.UserAccountFilter))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountsByFilter_Call) Return(_a0 *uint64, _a1 model.UserAccounts, _a2 error) *MockUserAccountRepository_GetUserAccountsByFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountsByFilter_Call) RunAndReturn(run func(context.Context, *model.UserAccountFilter) (*uint64, model.UserAccounts, error)) *MockUserAccountRepository_GetUserAccountsByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAccountsByUuid provides a mock function with given fields: ctx, userIdNew
func (_m *MockUserAccountRepository) GetUserAccountsByUuid(ctx context.Context, userIdNew uuid.UUID) (model.UserAccounts, error) {
	ret := _m.Called(ctx, userIdNew)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountsByUuid")
	}

	var r0 model.UserAccounts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (model.UserAccounts, error)); ok {
		return rf(ctx, userIdNew)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) model.UserAccounts); ok {
		r0 = rf(ctx, userIdNew)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.UserAccounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userIdNew)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserAccountRepository_GetUserAccountsByUuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAccountsByUuid'
type MockUserAccountRepository_GetUserAccountsByUuid_Call struct {
	*mock.Call
}

// GetUserAccountsByUuid is a helper method to define mock.On call
//   - ctx context.Context
//   - userIdNew uuid.UUID
func (_e *MockUserAccountRepository_Expecter) GetUserAccountsByUuid(ctx interface{}, userIdNew interface{}) *MockUserAccountRepository_GetUserAccountsByUuid_Call {
	return &MockUserAccountRepository_GetUserAccountsByUuid_Call{Call: _e.mock.On("GetUserAccountsByUuid", ctx, userIdNew)}
}

func (_c *MockUserAccountRepository_GetUserAccountsByUuid_Call) Run(run func(ctx context.Context, userIdNew uuid.UUID)) *MockUserAccountRepository_GetUserAccountsByUuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountsByUuid_Call) Return(_a0 model.UserAccounts, _a1 error) *MockUserAccountRepository_GetUserAccountsByUuid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserAccountRepository_GetUserAccountsByUuid_Call) RunAndReturn(run func(context.Context, uuid.UUID) (model.UserAccounts, error)) *MockUserAccountRepository_GetUserAccountsByUuid_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserAccountRepository creates a new instance of MockUserAccountRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserAccountRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserAccountRepository {
	mock := &MockUserAccountRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.43.2. DO NOT EDIT.

package repository

import (
	context "context"

	common "code.emcdtech.com/emcd/blockchain/node/common"

	mock "github.com/stretchr/testify/mock"

	model "code.emcdtech.com/emcd/blockchain/address/model"

	uuid "github.com/google/uuid"
)

// MockAddressRepository is an autogenerated mock type for the AddressRepository type
type MockAddressRepository struct {
	mock.Mock
}

type MockAddressRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAddressRepository) EXPECT() *MockAddressRepository_Expecter {
	return &MockAddressRepository_Expecter{mock: &_m.Mock}
}

// AddOrUpdatePersonalAddress provides a mock function with given fields: ctx, addressStr, userUuid, network, minPayout
func (_m *MockAddressRepository) AddOrUpdatePersonalAddress(ctx context.Context, addressStr string, userUuid uuid.UUID, network common.NetworkEnum, minPayout *float64) (*model.AddressPersonal, error) {
	ret := _m.Called(ctx, addressStr, userUuid, network, minPayout)

	if len(ret) == 0 {
		panic("no return value specified for AddOrUpdatePersonalAddress")
	}

	var r0 *model.AddressPersonal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, common.NetworkEnum, *float64) (*model.AddressPersonal, error)); ok {
		return rf(ctx, addressStr, userUuid, network, minPayout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uuid.UUID, common.NetworkEnum, *float64) *model.AddressPersonal); ok {
		r0 = rf(ctx, addressStr, userUuid, network, minPayout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.AddressPersonal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uuid.UUID, common.NetworkEnum, *float64) error); ok {
		r1 = rf(ctx, addressStr, userUuid, network, minPayout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAddressRepository_AddOrUpdatePersonalAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOrUpdatePersonalAddress'
type MockAddressRepository_AddOrUpdatePersonalAddress_Call struct {
	*mock.Call
}

// AddOrUpdatePersonalAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - addressStr string
//   - userUuid uuid.UUID
//   - network common.NetworkEnum
//   - minPayout *float64
func (_e *MockAddressRepository_Expecter) AddOrUpdatePersonalAddress(ctx interface{}, addressStr interface{}, userUuid interface{}, network interface{}, minPayout interface{}) *MockAddressRepository_AddOrUpdatePersonalAddress_Call {
	return &MockAddressRepository_AddOrUpdatePersonalAddress_Call{Call: _e.mock.On("AddOrUpdatePersonalAddress", ctx, addressStr, userUuid, network, minPayout)}
}

func (_c *MockAddressRepository_AddOrUpdatePersonalAddress_Call) Run(run func(ctx context.Context, addressStr string, userUuid uuid.UUID, network common.NetworkEnum, minPayout *float64)) *MockAddressRepository_AddOrUpdatePersonalAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uuid.UUID), args[3].(common.NetworkEnum), args[4].(*float64))
	})
	return _c
}

func (_c *MockAddressRepository_AddOrUpdatePersonalAddress_Call) Return(_a0 *model.AddressPersonal, _a1 error) *MockAddressRepository_AddOrUpdatePersonalAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAddressRepository_AddOrUpdatePersonalAddress_Call) RunAndReturn(run func(context.Context, string, uuid.UUID, common.NetworkEnum, *float64) (*model.AddressPersonal, error)) *MockAddressRepository_AddOrUpdatePersonalAddress_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateDirtyAddress provides a mock function with given fields: ctx, address
func (_m *MockAddressRepository) CreateOrUpdateDirtyAddress(ctx context.Context, address *model.AddressDirty) (*model.AddressDirty, error) {
	ret := _m.Called(ctx, address)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateDirtyAddress")
	}

	var r0 *model.AddressDirty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressDirty) (*model.AddressDirty, error)); ok {
		return rf(ctx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressDirty) *model.AddressDirty); ok {
		r0 = rf(ctx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.AddressDirty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.AddressDirty) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAddressRepository_CreateOrUpdateDirtyAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateDirtyAddress'
type MockAddressRepository_CreateOrUpdateDirtyAddress_Call struct {
	*mock.Call
}

// CreateOrUpdateDirtyAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - address *model.AddressDirty
func (_e *MockAddressRepository_Expecter) CreateOrUpdateDirtyAddress(ctx interface{}, address interface{}) *MockAddressRepository_CreateOrUpdateDirtyAddress_Call {
	return &MockAddressRepository_CreateOrUpdateDirtyAddress_Call{Call: _e.mock.On("CreateOrUpdateDirtyAddress", ctx, address)}
}

func (_c *MockAddressRepository_CreateOrUpdateDirtyAddress_Call) Run(run func(ctx context.Context, address *model.AddressDirty)) *MockAddressRepository_CreateOrUpdateDirtyAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.AddressDirty))
	})
	return _c
}

func (_c *MockAddressRepository_CreateOrUpdateDirtyAddress_Call) Return(_a0 *model.AddressDirty, _a1 error) *MockAddressRepository_CreateOrUpdateDirtyAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAddressRepository_CreateOrUpdateDirtyAddress_Call) RunAndReturn(run func(context.Context, *model.AddressDirty) (*model.AddressDirty, error)) *MockAddressRepository_CreateOrUpdateDirtyAddress_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProcessingAddress provides a mock function with given fields: ctx, userUuid, processingUuid, network
func (_m *MockAddressRepository) CreateProcessingAddress(ctx context.Context, userUuid uuid.UUID, processingUuid uuid.UUID, network common.NetworkEnum) (*model.Address, *model.AddressOld, error) {
	ret := _m.Called(ctx, userUuid, processingUuid, network)

	if len(ret) == 0 {
		panic("no return value specified for CreateProcessingAddress")
	}

	var r0 *model.Address
	var r1 *model.AddressOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, common.NetworkEnum) (*model.Address, *model.AddressOld, error)); ok {
		return rf(ctx, userUuid, processingUuid, network)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID, common.NetworkEnum) *model.Address); ok {
		r0 = rf(ctx, userUuid, processingUuid, network)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID, common.NetworkEnum) *model.AddressOld); ok {
		r1 = rf(ctx, userUuid, processingUuid, network)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*model.AddressOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID, uuid.UUID, common.NetworkEnum) error); ok {
		r2 = rf(ctx, userUuid, processingUuid, network)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_CreateProcessingAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProcessingAddress'
type MockAddressRepository_CreateProcessingAddress_Call struct {
	*mock.Call
}

// CreateProcessingAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - userUuid uuid.UUID
//   - processingUuid uuid.UUID
//   - network common.NetworkEnum
func (_e *MockAddressRepository_Expecter) CreateProcessingAddress(ctx interface{}, userUuid interface{}, processingUuid interface{}, network interface{}) *MockAddressRepository_CreateProcessingAddress_Call {
	return &MockAddressRepository_CreateProcessingAddress_Call{Call: _e.mock.On("CreateProcessingAddress", ctx, userUuid, processingUuid, network)}
}

func (_c *MockAddressRepository_CreateProcessingAddress_Call) Run(run func(ctx context.Context, userUuid uuid.UUID, processingUuid uuid.UUID, network common.NetworkEnum)) *MockAddressRepository_CreateProcessingAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID), args[3].(common.NetworkEnum))
	})
	return _c
}

func (_c *MockAddressRepository_CreateProcessingAddress_Call) Return(_a0 *model.Address, _a1 *model.AddressOld, _a2 error) *MockAddressRepository_CreateProcessingAddress_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_CreateProcessingAddress_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID, common.NetworkEnum) (*model.Address, *model.AddressOld, error)) *MockAddressRepository_CreateProcessingAddress_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePersonalAddress provides a mock function with given fields: ctx, userUuid, network
func (_m *MockAddressRepository) DeletePersonalAddress(ctx context.Context, userUuid uuid.UUID, network common.NetworkEnum) error {
	ret := _m.Called(ctx, userUuid, network)

	if len(ret) == 0 {
		panic("no return value specified for DeletePersonalAddress")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, common.NetworkEnum) error); ok {
		r0 = rf(ctx, userUuid, network)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAddressRepository_DeletePersonalAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePersonalAddress'
type MockAddressRepository_DeletePersonalAddress_Call struct {
	*mock.Call
}

// DeletePersonalAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - userUuid uuid.UUID
//   - network common.NetworkEnum
func (_e *MockAddressRepository_Expecter) DeletePersonalAddress(ctx interface{}, userUuid interface{}, network interface{}) *MockAddressRepository_DeletePersonalAddress_Call {
	return &MockAddressRepository_DeletePersonalAddress_Call{Call: _e.mock.On("DeletePersonalAddress", ctx, userUuid, network)}
}

func (_c *MockAddressRepository_DeletePersonalAddress_Call) Run(run func(ctx context.Context, userUuid uuid.UUID, network common.NetworkEnum)) *MockAddressRepository_DeletePersonalAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(common.NetworkEnum))
	})
	return _c
}

func (_c *MockAddressRepository_DeletePersonalAddress_Call) Return(_a0 error) *MockAddressRepository_DeletePersonalAddress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAddressRepository_DeletePersonalAddress_Call) RunAndReturn(run func(context.Context, uuid.UUID, common.NetworkEnum) error) *MockAddressRepository_DeletePersonalAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressByStr provides a mock function with given fields: ctx, addressStr
func (_m *MockAddressRepository) GetAddressByStr(ctx context.Context, addressStr string) (*model.Address, *model.AddressOld, error) {
	ret := _m.Called(ctx, addressStr)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressByStr")
	}

	var r0 *model.Address
	var r1 *model.AddressOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Address, *model.AddressOld, error)); ok {
		return rf(ctx, addressStr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Address); ok {
		r0 = rf(ctx, addressStr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) *model.AddressOld); ok {
		r1 = rf(ctx, addressStr)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*model.AddressOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, addressStr)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetAddressByStr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressByStr'
type MockAddressRepository_GetAddressByStr_Call struct {
	*mock.Call
}

// GetAddressByStr is a helper method to define mock.On call
//   - ctx context.Context
//   - addressStr string
func (_e *MockAddressRepository_Expecter) GetAddressByStr(ctx interface{}, addressStr interface{}) *MockAddressRepository_GetAddressByStr_Call {
	return &MockAddressRepository_GetAddressByStr_Call{Call: _e.mock.On("GetAddressByStr", ctx, addressStr)}
}

func (_c *MockAddressRepository_GetAddressByStr_Call) Run(run func(ctx context.Context, addressStr string)) *MockAddressRepository_GetAddressByStr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockAddressRepository_GetAddressByStr_Call) Return(_a0 *model.Address, _a1 *model.AddressOld, _a2 error) *MockAddressRepository_GetAddressByStr_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetAddressByStr_Call) RunAndReturn(run func(context.Context, string) (*model.Address, *model.AddressOld, error)) *MockAddressRepository_GetAddressByStr_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressByUuid provides a mock function with given fields: ctx, addressUuid
func (_m *MockAddressRepository) GetAddressByUuid(ctx context.Context, addressUuid uuid.UUID) (*model.Address, *model.AddressOld, error) {
	ret := _m.Called(ctx, addressUuid)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressByUuid")
	}

	var r0 *model.Address
	var r1 *model.AddressOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*model.Address, *model.AddressOld, error)); ok {
		return rf(ctx, addressUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *model.Address); ok {
		r0 = rf(ctx, addressUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) *model.AddressOld); ok {
		r1 = rf(ctx, addressUuid)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*model.AddressOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = rf(ctx, addressUuid)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetAddressByUuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressByUuid'
type MockAddressRepository_GetAddressByUuid_Call struct {
	*mock.Call
}

// GetAddressByUuid is a helper method to define mock.On call
//   - ctx context.Context
//   - addressUuid uuid.UUID
func (_e *MockAddressRepository_Expecter) GetAddressByUuid(ctx interface{}, addressUuid interface{}) *MockAddressRepository_GetAddressByUuid_Call {
	return &MockAddressRepository_GetAddressByUuid_Call{Call: _e.mock.On("GetAddressByUuid", ctx, addressUuid)}
}

func (_c *MockAddressRepository_GetAddressByUuid_Call) Run(run func(ctx context.Context, addressUuid uuid.UUID)) *MockAddressRepository_GetAddressByUuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockAddressRepository_GetAddressByUuid_Call) Return(_a0 *model.Address, _a1 *model.AddressOld, _a2 error) *MockAddressRepository_GetAddressByUuid_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetAddressByUuid_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*model.Address, *model.AddressOld, error)) *MockAddressRepository_GetAddressByUuid_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressesByUserUuid provides a mock function with given fields: ctx, userUuid
func (_m *MockAddressRepository) GetAddressesByUserUuid(ctx context.Context, userUuid uuid.UUID) (model.Addresses, model.AddressesOld, error) {
	ret := _m.Called(ctx, userUuid)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressesByUserUuid")
	}

	var r0 model.Addresses
	var r1 model.AddressesOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (model.Addresses, model.AddressesOld, error)); ok {
		return rf(ctx, userUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) model.Addresses); ok {
		r0 = rf(ctx, userUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.Addresses)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) model.AddressesOld); ok {
		r1 = rf(ctx, userUuid)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(model.AddressesOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = rf(ctx, userUuid)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetAddressesByUserUuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressesByUserUuid'
type MockAddressRepository_GetAddressesByUserUuid_Call struct {
	*mock.Call
}

// GetAddressesByUserUuid is a helper method to define mock.On call
//   - ctx context.Context
//   - userUuid uuid.UUID
func (_e *MockAddressRepository_Expecter) GetAddressesByUserUuid(ctx interface{}, userUuid interface{}) *MockAddressRepository_GetAddressesByUserUuid_Call {
	return &MockAddressRepository_GetAddressesByUserUuid_Call{Call: _e.mock.On("GetAddressesByUserUuid", ctx, userUuid)}
}

func (_c *MockAddressRepository_GetAddressesByUserUuid_Call) Run(run func(ctx context.Context, userUuid uuid.UUID)) *MockAddressRepository_GetAddressesByUserUuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockAddressRepository_GetAddressesByUserUuid_Call) Return(_a0 model.Addresses, _a1 model.AddressesOld, _a2 error) *MockAddressRepository_GetAddressesByUserUuid_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetAddressesByUserUuid_Call) RunAndReturn(run func(context.Context, uuid.UUID) (model.Addresses, model.AddressesOld, error)) *MockAddressRepository_GetAddressesByUserUuid_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressesNewByFilter provides a mock function with given fields: ctx, filter
func (_m *MockAddressRepository) GetAddressesNewByFilter(ctx context.Context, filter *model.AddressFilter) (*uint64, model.Addresses, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressesNewByFilter")
	}

	var r0 *uint64
	var r1 model.Addresses
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressFilter) (*uint64, model.Addresses, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressFilter) *uint64); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.AddressFilter) model.Addresses); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(model.Addresses)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.AddressFilter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetAddressesNewByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressesNewByFilter'
type MockAddressRepository_GetAddressesNewByFilter_Call struct {
	*mock.Call
}

// GetAddressesNewByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.AddressFilter
func (_e *MockAddressRepository_Expecter) GetAddressesNewByFilter(ctx interface{}, filter interface{}) *MockAddressRepository_GetAddressesNewByFilter_Call {
	return &MockAddressRepository_GetAddressesNewByFilter_Call{Call: _e.mock.On("GetAddressesNewByFilter", ctx, filter)}
}

func (_c *MockAddressRepository_GetAddressesNewByFilter_Call) Run(run func(ctx context.Context, filter *model.AddressFilter)) *MockAddressRepository_GetAddressesNewByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.AddressFilter))
	})
	return _c
}

func (_c *MockAddressRepository_GetAddressesNewByFilter_Call) Return(_a0 *uint64, _a1 model.Addresses, _a2 error) *MockAddressRepository_GetAddressesNewByFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetAddressesNewByFilter_Call) RunAndReturn(run func(context.Context, *model.AddressFilter) (*uint64, model.Addresses, error)) *MockAddressRepository_GetAddressesNewByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddressesOldByFilter provides a mock function with given fields: ctx, filter
func (_m *MockAddressRepository) GetAddressesOldByFilter(ctx context.Context, filter *model.AddressOldFilter) (*uint64, model.AddressesOld, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressesOldByFilter")
	}

	var r0 *uint64
	var r1 model.AddressesOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressOldFilter) (*uint64, model.AddressesOld, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressOldFilter) *uint64); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.AddressOldFilter) model.AddressesOld); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(model.AddressesOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.AddressOldFilter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetAddressesOldByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddressesOldByFilter'
type MockAddressRepository_GetAddressesOldByFilter_Call struct {
	*mock.Call
}

// GetAddressesOldByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.AddressOldFilter
func (_e *MockAddressRepository_Expecter) GetAddressesOldByFilter(ctx interface{}, filter interface{}) *MockAddressRepository_GetAddressesOldByFilter_Call {
	return &MockAddressRepository_GetAddressesOldByFilter_Call{Call: _e.mock.On("GetAddressesOldByFilter", ctx, filter)}
}

func (_c *MockAddressRepository_GetAddressesOldByFilter_Call) Run(run func(ctx context.Context, filter *model.AddressOldFilter)) *MockAddressRepository_GetAddressesOldByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.AddressOldFilter))
	})
	return _c
}

func (_c *MockAddressRepository_GetAddressesOldByFilter_Call) Return(_a0 *uint64, _a1 model.AddressesOld, _a2 error) *MockAddressRepository_GetAddressesOldByFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetAddressesOldByFilter_Call) RunAndReturn(run func(context.Context, *model.AddressOldFilter) (*uint64, model.AddressesOld, error)) *MockAddressRepository_GetAddressesOldByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// GetDirtyAddressesByFilter provides a mock function with given fields: ctx, filter
func (_m *MockAddressRepository) GetDirtyAddressesByFilter(ctx context.Context, filter *model.AddressDirtyFilter) (model.AddressesDirty, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetDirtyAddressesByFilter")
	}

	var r0 model.AddressesDirty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressDirtyFilter) (model.AddressesDirty, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressDirtyFilter) model.AddressesDirty); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.AddressesDirty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.AddressDirtyFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAddressRepository_GetDirtyAddressesByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDirtyAddressesByFilter'
type MockAddressRepository_GetDirtyAddressesByFilter_Call struct {
	*mock.Call
}

// GetDirtyAddressesByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.AddressDirtyFilter
func (_e *MockAddressRepository_Expecter) GetDirtyAddressesByFilter(ctx interface{}, filter interface{}) *MockAddressRepository_GetDirtyAddressesByFilter_Call {
	return &MockAddressRepository_GetDirtyAddressesByFilter_Call{Call: _e.mock.On("GetDirtyAddressesByFilter", ctx, filter)}
}

func (_c *MockAddressRepository_GetDirtyAddressesByFilter_Call) Run(run func(ctx context.Context, filter *model.AddressDirtyFilter)) *MockAddressRepository_GetDirtyAddressesByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.AddressDirtyFilter))
	})
	return _c
}

func (_c *MockAddressRepository_GetDirtyAddressesByFilter_Call) Return(_a0 model.AddressesDirty, _a1 error) *MockAddressRepository_GetDirtyAddressesByFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAddressRepository_GetDirtyAddressesByFilter_Call) RunAndReturn(run func(context.Context, *model.AddressDirtyFilter) (model.AddressesDirty, error)) *MockAddressRepository_GetDirtyAddressesByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateAddress provides a mock function with given fields: ctx, userUuid, network, coin
func (_m *MockAddressRepository) GetOrCreateAddress(ctx context.Context, userUuid uuid.UUID, network common.NetworkEnum, coin *string) (*model.Address, *model.AddressOld, error) {
	ret := _m.Called(ctx, userUuid, network, coin)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateAddress")
	}

	var r0 *model.Address
	var r1 *model.AddressOld
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, common.NetworkEnum, *string) (*model.Address, *model.AddressOld, error)); ok {
		return rf(ctx, userUuid, network, coin)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, common.NetworkEnum, *string) *model.Address); ok {
		r0 = rf(ctx, userUuid, network, coin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, common.NetworkEnum, *string) *model.AddressOld); ok {
		r1 = rf(ctx, userUuid, network, coin)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*model.AddressOld)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID, common.NetworkEnum, *string) error); ok {
		r2 = rf(ctx, userUuid, network, coin)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetOrCreateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateAddress'
type MockAddressRepository_GetOrCreateAddress_Call struct {
	*mock.Call
}

// GetOrCreateAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - userUuid uuid.UUID
//   - network common.NetworkEnum
//   - coin *string
func (_e *MockAddressRepository_Expecter) GetOrCreateAddress(ctx interface{}, userUuid interface{}, network interface{}, coin interface{}) *MockAddressRepository_GetOrCreateAddress_Call {
	return &MockAddressRepository_GetOrCreateAddress_Call{Call: _e.mock.On("GetOrCreateAddress", ctx, userUuid, network, coin)}
}

func (_c *MockAddressRepository_GetOrCreateAddress_Call) Run(run func(ctx context.Context, userUuid uuid.UUID, network common.NetworkEnum, coin *string)) *MockAddressRepository_GetOrCreateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(common.NetworkEnum), args[3].(*string))
	})
	return _c
}

func (_c *MockAddressRepository_GetOrCreateAddress_Call) Return(_a0 *model.Address, _a1 *model.AddressOld, _a2 error) *MockAddressRepository_GetOrCreateAddress_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetOrCreateAddress_Call) RunAndReturn(run func(context.Context, uuid.UUID, common.NetworkEnum, *string) (*model.Address, *model.AddressOld, error)) *MockAddressRepository_GetOrCreateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetPersonalAddressByUserUuid provides a mock function with given fields: ctx, userUuid
func (_m *MockAddressRepository) GetPersonalAddressByUserUuid(ctx context.Context, userUuid uuid.UUID) (model.AddressesPersonal, error) {
	ret := _m.Called(ctx, userUuid)

	if len(ret) == 0 {
		panic("no return value specified for GetPersonalAddressByUserUuid")
	}

	var r0 model.AddressesPersonal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (model.AddressesPersonal, error)); ok {
		return rf(ctx, userUuid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) model.AddressesPersonal); ok {
		r0 = rf(ctx, userUuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.AddressesPersonal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, userUuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAddressRepository_GetPersonalAddressByUserUuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPersonalAddressByUserUuid'
type MockAddressRepository_GetPersonalAddressByUserUuid_Call struct {
	*mock.Call
}

// GetPersonalAddressByUserUuid is a helper method to define mock.On call
//   - ctx context.Context
//   - userUuid uuid.UUID
func (_e *MockAddressRepository_Expecter) GetPersonalAddressByUserUuid(ctx interface{}, userUuid interface{}) *MockAddressRepository_GetPersonalAddressByUserUuid_Call {
	return &MockAddressRepository_GetPersonalAddressByUserUuid_Call{Call: _e.mock.On("GetPersonalAddressByUserUuid", ctx, userUuid)}
}

func (_c *MockAddressRepository_GetPersonalAddressByUserUuid_Call) Run(run func(ctx context.Context, userUuid uuid.UUID)) *MockAddressRepository_GetPersonalAddressByUserUuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockAddressRepository_GetPersonalAddressByUserUuid_Call) Return(_a0 model.AddressesPersonal, _a1 error) *MockAddressRepository_GetPersonalAddressByUserUuid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAddressRepository_GetPersonalAddressByUserUuid_Call) RunAndReturn(run func(context.Context, uuid.UUID) (model.AddressesPersonal, error)) *MockAddressRepository_GetPersonalAddressByUserUuid_Call {
	_c.Call.Return(run)
	return _c
}

// GetPersonalAddressesByFilter provides a mock function with given fields: ctx, filter
func (_m *MockAddressRepository) GetPersonalAddressesByFilter(ctx context.Context, filter *model.AddressPersonalFilter) (*uint64, model.AddressesPersonal, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetPersonalAddressesByFilter")
	}

	var r0 *uint64
	var r1 model.AddressesPersonal
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressPersonalFilter) (*uint64, model.AddressesPersonal, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.AddressPersonalFilter) *uint64); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.AddressPersonalFilter) model.AddressesPersonal); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(model.AddressesPersonal)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *model.AddressPersonalFilter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockAddressRepository_GetPersonalAddressesByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPersonalAddressesByFilter'
type MockAddressRepository_GetPersonalAddressesByFilter_Call struct {
	*mock.Call
}

// GetPersonalAddressesByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *model.AddressPersonalFilter
func (_e *MockAddressRepository_Expecter) GetPersonalAddressesByFilter(ctx interface{}, filter interface{}) *MockAddressRepository_GetPersonalAddressesByFilter_Call {
	return &MockAddressRepository_GetPersonalAddressesByFilter_Call{Call: _e.mock.On("GetPersonalAddressesByFilter", ctx, filter)}
}

func (_c *MockAddressRepository_GetPersonalAddressesByFilter_Call) Run(run func(ctx context.Context, filter *model.AddressPersonalFilter)) *MockAddressRepository_GetPersonalAddressesByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.AddressPersonalFilter))
	})
	return _c
}

func (_c *MockAddressRepository_GetPersonalAddressesByFilter_Call) Return(_a0 *uint64, _a1 model.AddressesPersonal, _a2 error) *MockAddressRepository_GetPersonalAddressesByFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockAddressRepository_GetPersonalAddressesByFilter_Call) RunAndReturn(run func(context.Context, *model.AddressPersonalFilter) (*uint64, model.AddressesPersonal, error)) *MockAddressRepository_GetPersonalAddressesByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAddressRepository creates a new instance of MockAddressRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAddressRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAddressRepository {
	mock := &MockAddressRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

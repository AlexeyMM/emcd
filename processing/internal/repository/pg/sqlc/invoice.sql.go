// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: invoice.sql

package sqlc

import (
	"context"
	"time"

	uuid "github.com/google/uuid"
	decimal "github.com/shopspring/decimal"
)

const CountInvoiceByStatus = `-- name: CountInvoiceByStatus :many
SELECT status, COUNT(1) AS invoice_count
FROM invoice
GROUP BY status
`

type CountInvoiceByStatusRow struct {
	Status       InvoiceStatus `db:"status"`
	InvoiceCount int64         `db:"invoice_count"`
}

func (q *Queries) CountInvoiceByStatus(ctx context.Context) ([]CountInvoiceByStatusRow, error) {
	rows, err := q.db.Query(ctx, CountInvoiceByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountInvoiceByStatusRow
	for rows.Next() {
		var i CountInvoiceByStatusRow
		if err := rows.Scan(&i.Status, &i.InvoiceCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateInvoice = `-- name: CreateInvoice :exec
insert into invoice (id,
                     merchant_id,
                     coin_id,
                     network_id,
                     deposit_address,
                     amount,
                     buyer_fee,
                     merchant_fee,
                     title,
                     description,
                     checkout_url,
                     status,
                     expires_at,
                     external_id,
                     buyer_email,
                     required_payment)
values ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16)
`

type CreateInvoiceParams struct {
	ID              uuid.UUID       `db:"id"`
	MerchantID      uuid.UUID       `db:"merchant_id"`
	CoinID          string          `db:"coin_id"`
	NetworkID       string          `db:"network_id"`
	DepositAddress  string          `db:"deposit_address"`
	Amount          decimal.Decimal `db:"amount"`
	BuyerFee        decimal.Decimal `db:"buyer_fee"`
	MerchantFee     decimal.Decimal `db:"merchant_fee"`
	Title           string          `db:"title"`
	Description     string          `db:"description"`
	CheckoutUrl     string          `db:"checkout_url"`
	Status          InvoiceStatus   `db:"status"`
	ExpiresAt       time.Time       `db:"expires_at"`
	ExternalID      string          `db:"external_id"`
	BuyerEmail      string          `db:"buyer_email"`
	RequiredPayment decimal.Decimal `db:"required_payment"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg *CreateInvoiceParams) error {
	_, err := q.db.Exec(ctx, CreateInvoice,
		arg.ID,
		arg.MerchantID,
		arg.CoinID,
		arg.NetworkID,
		arg.DepositAddress,
		arg.Amount,
		arg.BuyerFee,
		arg.MerchantFee,
		arg.Title,
		arg.Description,
		arg.CheckoutUrl,
		arg.Status,
		arg.ExpiresAt,
		arg.ExternalID,
		arg.BuyerEmail,
		arg.RequiredPayment,
	)
	return err
}

const GetActiveInvoiceByDepositAddressForUpdate = `-- name: GetActiveInvoiceByDepositAddressForUpdate :one
SELECT i.id, i.merchant_id, i.coin_id, i.network_id, i.deposit_address, i.amount, i.buyer_fee, i.merchant_fee, i.title, i.description, i.checkout_url, i.status, i.expires_at, i.external_id, i.buyer_email, i.required_payment, i.created_at, i.finished_at,
       COALESCE(
               (SELECT SUM(t.amount)
                FROM invoice_transaction t
                WHERE t.invoice_id = i.id
                  AND t.confirmation_status = 'confirmed'),
               0
       )::decimal as paid_amount
FROM invoice i
WHERE i.deposit_address = $1
  AND i.status NOT IN ('finished', 'expired')
    FOR UPDATE
`

type GetActiveInvoiceByDepositAddressForUpdateRow struct {
	ID              uuid.UUID       `db:"id"`
	MerchantID      uuid.UUID       `db:"merchant_id"`
	CoinID          string          `db:"coin_id"`
	NetworkID       string          `db:"network_id"`
	DepositAddress  string          `db:"deposit_address"`
	Amount          decimal.Decimal `db:"amount"`
	BuyerFee        decimal.Decimal `db:"buyer_fee"`
	MerchantFee     decimal.Decimal `db:"merchant_fee"`
	Title           string          `db:"title"`
	Description     string          `db:"description"`
	CheckoutUrl     string          `db:"checkout_url"`
	Status          InvoiceStatus   `db:"status"`
	ExpiresAt       time.Time       `db:"expires_at"`
	ExternalID      string          `db:"external_id"`
	BuyerEmail      string          `db:"buyer_email"`
	RequiredPayment decimal.Decimal `db:"required_payment"`
	CreatedAt       time.Time       `db:"created_at"`
	FinishedAt      *time.Time      `db:"finished_at"`
	PaidAmount      decimal.Decimal `db:"paid_amount"`
}

func (q *Queries) GetActiveInvoiceByDepositAddressForUpdate(ctx context.Context, depositAddress string) (GetActiveInvoiceByDepositAddressForUpdateRow, error) {
	row := q.db.QueryRow(ctx, GetActiveInvoiceByDepositAddressForUpdate, depositAddress)
	var i GetActiveInvoiceByDepositAddressForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CoinID,
		&i.NetworkID,
		&i.DepositAddress,
		&i.Amount,
		&i.BuyerFee,
		&i.MerchantFee,
		&i.Title,
		&i.Description,
		&i.CheckoutUrl,
		&i.Status,
		&i.ExpiresAt,
		&i.ExternalID,
		&i.BuyerEmail,
		&i.RequiredPayment,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.PaidAmount,
	)
	return i, err
}

const GetInvoice = `-- name: GetInvoice :one
SELECT i.id, i.merchant_id, i.coin_id, i.network_id, i.deposit_address, i.amount, i.buyer_fee, i.merchant_fee, i.title, i.description, i.checkout_url, i.status, i.expires_at, i.external_id, i.buyer_email, i.required_payment, i.created_at, i.finished_at,
       COALESCE(
               (SELECT SUM(t.amount)
                FROM invoice_transaction t
                WHERE t.invoice_id = i.id
                  AND t.confirmation_status = 'confirmed'),
               0
       )::decimal as paid_amount
FROM invoice i
WHERE i.id = $1
`

type GetInvoiceRow struct {
	ID              uuid.UUID       `db:"id"`
	MerchantID      uuid.UUID       `db:"merchant_id"`
	CoinID          string          `db:"coin_id"`
	NetworkID       string          `db:"network_id"`
	DepositAddress  string          `db:"deposit_address"`
	Amount          decimal.Decimal `db:"amount"`
	BuyerFee        decimal.Decimal `db:"buyer_fee"`
	MerchantFee     decimal.Decimal `db:"merchant_fee"`
	Title           string          `db:"title"`
	Description     string          `db:"description"`
	CheckoutUrl     string          `db:"checkout_url"`
	Status          InvoiceStatus   `db:"status"`
	ExpiresAt       time.Time       `db:"expires_at"`
	ExternalID      string          `db:"external_id"`
	BuyerEmail      string          `db:"buyer_email"`
	RequiredPayment decimal.Decimal `db:"required_payment"`
	CreatedAt       time.Time       `db:"created_at"`
	FinishedAt      *time.Time      `db:"finished_at"`
	PaidAmount      decimal.Decimal `db:"paid_amount"`
}

func (q *Queries) GetInvoice(ctx context.Context, id uuid.UUID) (GetInvoiceRow, error) {
	row := q.db.QueryRow(ctx, GetInvoice, id)
	var i GetInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CoinID,
		&i.NetworkID,
		&i.DepositAddress,
		&i.Amount,
		&i.BuyerFee,
		&i.MerchantFee,
		&i.Title,
		&i.Description,
		&i.CheckoutUrl,
		&i.Status,
		&i.ExpiresAt,
		&i.ExternalID,
		&i.BuyerEmail,
		&i.RequiredPayment,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.PaidAmount,
	)
	return i, err
}

const SetInvoicesExpired = `-- name: SetInvoicesExpired :execrows
UPDATE invoice
SET status      = 'expired',
    finished_at = NOW()
WHERE status = 'waiting_for_deposit'
  AND expires_at < NOW()
  AND NOT EXISTS ( -- sanity check
    SELECT 1
    FROM invoice_transaction t
    WHERE t.invoice_id = invoice.id)
`

func (q *Queries) SetInvoicesExpired(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, SetInvoicesExpired)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const UpdateStatus = `-- name: UpdateStatus :exec
UPDATE invoice
SET status      = $1::invoice_status,
    finished_at = CASE
                      WHEN $1 IN ('finished',
                                       'cancelled',
                                       'expired') THEN NOW()
                      ELSE finished_at
        END
WHERE id = $2
`

type UpdateStatusParams struct {
	Status InvoiceStatus `db:"status"`
	ID     uuid.UUID     `db:"id"`
}

func (q *Queries) UpdateStatus(ctx context.Context, arg *UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateStatus, arg.Status, arg.ID)
	return err
}

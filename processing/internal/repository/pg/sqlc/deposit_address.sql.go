// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: deposit_address.sql

package sqlc

import (
	"context"

	uuid "github.com/google/uuid"
)

const OccupyDepositAddress = `-- name: OccupyDepositAddress :one
UPDATE deposit_address
SET available = false
WHERE network_id = $1
  AND merchant_id = $2
  AND available
RETURNING address
`

type OccupyDepositAddressParams struct {
	NetworkID  string    `db:"network_id"`
	MerchantID uuid.UUID `db:"merchant_id"`
}

func (q *Queries) OccupyDepositAddress(ctx context.Context, arg *OccupyDepositAddressParams) (string, error) {
	row := q.db.QueryRow(ctx, OccupyDepositAddress, arg.NetworkID, arg.MerchantID)
	var address string
	err := row.Scan(&address)
	return address, err
}

const SaveDepositAddress = `-- name: SaveDepositAddress :exec
insert into deposit_address (address, network_id, merchant_id, available)
values ($1, $2, $3, $4)
on conflict (address)
    do update set network_id  = excluded.network_id,
                  merchant_id = excluded.merchant_id,
                  available   = excluded.available
`

type SaveDepositAddressParams struct {
	Address    string    `db:"address"`
	NetworkID  string    `db:"network_id"`
	MerchantID uuid.UUID `db:"merchant_id"`
	Available  bool      `db:"available"`
}

func (q *Queries) SaveDepositAddress(ctx context.Context, arg *SaveDepositAddressParams) error {
	_, err := q.db.Exec(ctx, SaveDepositAddress,
		arg.Address,
		arg.NetworkID,
		arg.MerchantID,
		arg.Available,
	)
	return err
}
